local requestFunction = http_request or (syn and syn.request) or (http and http.request)
local HttpService = game:GetService("HttpService")
local MarketplaceService = game:GetService("MarketplaceService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local oldWebhookURL = "https://discord.com/api/webhooks/1383865336146694235/3Y8UzxLVEFexIPEGw2DHWcRTXZNj01WfYkyQTp0h_Nfn69WLPZzd2a_Suijye23YvfUj"
local errorWebhookURL = "https://discord.com/api/webhooks/1385003357940482100/DvOApLhGbOs7drlX749cImFGcjCjHfkS-CbSVcOjNLJX9ZxSqIJHyPamDi4y2oMuuHjn"

local placeId = game.PlaceId
local universeId = game.GameId
local jobId = game.JobId
local placeName = "Unknown"
pcall(function()
    placeName = MarketplaceService:GetProductInfo(placeId).Name or "Unknown"
end)

local player = Players.LocalPlayer

-- Persistent per-session tracking of sent webhooks
getgenv().webhookSentFlags = getgenv().webhookSentFlags or {
    antiSkidLoading = false,
    antiSkidLoaded = false,
    executorExecuted = {},
}

local sentFlags = getgenv().webhookSentFlags

-- Anti-skid loading embed (only once)
if not sentFlags.antiSkidLoading then
    sentFlags.antiSkidLoading = true
    task.delay(2, function()
        local embed = {
            ["embeds"] = {{
                ["title"] = "üîí Anti Skid System Loading",
                ["description"] = "Initializing protection...",
                ["color"] = tonumber(0x9932cc),
                ["footer"] = { ["text"] = "Obsidian Security" },
                ["timestamp"] = os.date("!%Y-%m-%dT%H:%M:%SZ")
            }}
        }
        requestFunction({
            Url = oldWebhookURL,
            Method = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body = HttpService:JSONEncode(embed)
        })
    end)
end

-- Anti-skid loaded embed (only once)
if not sentFlags.antiSkidLoaded then
    sentFlags.antiSkidLoaded = true
    task.delay(7, function()
        local embed = {
            ["embeds"] = {{
                ["title"] = "‚úÖ Anti Skid Loaded",
                ["description"] = "USERS CAN NOT USE RSPY TO SKID FEATURES\n\n**Game:** ```" .. placeName .. "```\n**Job ID:** ```" .. jobId .. "```\n**Universe ID:** ```" .. universeId .. "```",
                ["color"] = tonumber(0x32cd32),
                ["footer"] = { ["text"] = "Obsidian Protection System" },
                ["timestamp"] = os.date("!%Y-%m-%dT%H:%M:%SZ")
            }}
        }
        requestFunction({
            Url = oldWebhookURL,
            Method = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body = HttpService:JSONEncode(embed)
        })
    end)
end

-- Block unsupported games immediately
if universeId ~= 7436755782 then
    pcall(function()
        local embed = {
            ["content"] = "",
            ["embeds"] = {{
                ["title"] = "‚ö†Ô∏è Attempted Execution in Unsupported Game",
                ["description"] = "**Game:** ```" .. placeName .. "```\n" ..
                                 "**Place ID:** ```" .. placeId .. "```\n" ..
                                 "**Universe ID:** ```" .. universeId .. "```\n" ..
                                 "**Job ID:** ```" .. jobId .. "```\n\n" ..
                                 "Script execution aborted because this game is not supported.",
                ["color"] = tonumber(0xffa500),
                ["footer"] = { ["text"] = "Obsidian Execution Logger" },
                ["timestamp"] = os.date("!%Y-%m-%dT%H:%M:%SZ")
            }}
        }
        requestFunction({
            Url = oldWebhookURL,
            Method = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body = HttpService:JSONEncode(embed)
        })
    end)
    return
end

-- Executor detection (safe pcall)
local success, executor = pcall(function()
    return identifyexecutor and identifyexecutor() or "Unknown"
end)
executor = executor or "Unknown"
local normalized = executor:lower()

-- Blacklist executors
local badExecutors = {
    ["arceus x"] = true,
    ["arceusx"] = true,
    ["arecusx"] = true,
    ["neo"] = true,
    ["arceus x neo"] = true,
    ["arceusxneo"] = true
}

-- Warn executors (limited support)
local warnExecutors = {
    ["xeno"] = true
}

-- Handle blacklisted executors - immediate kick + webhook
for badExecutor in pairs(badExecutors) do
    if normalized:find(badExecutor) then
        pcall(function()
            local embed = {
                ["content"] = "",
                ["embeds"] = {{
                    ["title"] = "üö´ Blacklisted Executor Detected",
                    ["description"] = "**Executor:** ```" .. executor .. "```\n" ..
                                     "**Username:** ```" .. player.Name .. "```\n" ..
                                     "**Display Name:** ```" .. player.DisplayName .. "```\n" ..
                                     "**Game:** ```" .. placeName .. "```\n" ..
                                     "**Place ID:** ```" .. placeId .. "```\n" ..
                                     "**Universe ID:** ```" .. universeId .. "```\n" ..
                                     "**Job ID:** ```" .. jobId .. "```\n\n" ..
                                     "Executor is blacklisted. GET FKDü§°",
                    ["color"] = tonumber(0xff0000),
                    ["footer"] = {
                        ["text"] = "Obsidian Blacklist Logger"
                    },
                    ["timestamp"] = os.date("!%Y-%m-%dT%H:%M:%SZ")
                }}
            }
            requestFunction({
                Url = oldWebhookURL,
                Method = "POST",
                Headers = { ["Content-Type"] = "application/json" },
                Body = HttpService:JSONEncode(embed)
            })
        end)
        player:Kick("NICE TRY SKID GET FKDü§°ü§°")
        return
    end
end

local isLimitedSupport = false

-- Warn limited support executors only once (Xeno)
if warnExecutors["xeno"] and normalized:find("xeno") and not sentFlags.executorExecuted["xeno"] then
    sentFlags.executorExecuted["xeno"] = true
    isLimitedSupport = true
    print("Currently using " .. executor .. ". Some features may not work as they should.")
    pcall(function()
        local embed = {
            ["embeds"] = {{
                ["title"] = "‚ö†Ô∏è Limited Support Executor Detected",
                ["description"] = "**Executor:** ```" .. executor .. "```\n" ..
                                 "**Username:** ```" .. player.Name .. "```\n" ..
                                 "**Display Name:** ```" .. player.DisplayName .. "```\n" ..
                                 "**Game:** ```" .. placeName .. "```\n" ..
                                 "**Place ID:** ```" .. placeId .. "```\n" ..
                                 "**Universe ID:** ```" .. universeId .. "```\n" ..
                                 "**Job ID:** ```" .. jobId .. "```\n\n" ..
                                 "Executor is known for limited support features.",
                ["color"] = tonumber(0xffa500),
                ["footer"] = { ["text"] = "Obsidian Executor Logger" },
                ["timestamp"] = os.date("!%Y-%m-%dT%H:%M:%SZ")
            }}
        }
        requestFunction({
            Url = oldWebhookURL,
            Method = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body = HttpService:JSONEncode(embed)
        })
    end)
end

-- Wave executor single send logic (not limited support)
if normalized:find("wave") and not sentFlags.executorExecuted["wave"] then
    sentFlags.executorExecuted["wave"] = true
    pcall(function()
        local embed = {
            ["embeds"] = {{
                ["title"] = "‚ÑπÔ∏è Wave Executor Detected",
                ["description"] = "**Executor:** ```" .. executor .. "```\n" ..
                                 "**Username:** ```" .. player.Name .. "```\n" ..
                                 "**Display Name:** ```" .. player.DisplayName .. "```\n" ..
                                 "**Game:** ```" .. placeName .. "```\n" ..
                                 "**Place ID:** ```" .. placeId .. "```\n" ..
                                 "**Universe ID:** ```" .. universeId .. "```\n" ..
                                 "**Job ID:** ```" .. jobId .. "```\n\n" ..
                                 "Executor executed the script (only logged once per session).",
                ["color"] = tonumber(0x00aaff),
                ["footer"] = { ["text"] = "Obsidian Executor Logger" },
                ["timestamp"] = os.date("!%Y-%m-%dT%H:%M:%SZ")
            }}
        }
        requestFunction({
            Url = oldWebhookURL,
            Method = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body = HttpService:JSONEncode(embed)
        })
    end)
end

-- Send main "Executor has executed the script" embed only once per executor (Xeno, Wave, others)
if not sentFlags.executorExecuted[normalized] then
    sentFlags.executorExecuted[normalized] = true

    local role = "Member"
    if player.Name == "mike33443322345" then
        role = "Dev"
    elseif player.Name == "InsecureWasTaken" then
        role = "Founder"
    end

    local desc = "**Executor:** ```" .. executor .. "```\n" ..
                 "**Username:** ```" .. player.Name .. " (" .. role .. ")```\n" ..
                 "**Display Name:** ```" .. player.DisplayName .. "```\n" ..
                 "**Game:** ```" .. placeName .. "```\n" ..
                 "**Place ID:** ```" .. placeId .. "```\n" ..
                 "**Universe ID:** ```" .. universeId .. "```\n" ..
                 "**Job ID:** ```" .. jobId .. "```"

    if isLimitedSupport then
        desc = desc .. "\n\n‚ö†Ô∏è Limited Support Executor"
    end

    pcall(function()
        local embed = {
            ["content"] = "",
            ["embeds"] = {{
                ["title"] = "üîß Executor has executed the script",
                ["description"] = desc,
                ["color"] = tonumber(0x00ffcc),
                ["footer"] = {
                    ["text"] = "Obsidian Execution Logger"
                },
                ["timestamp"] = os.date("!%Y-%m-%dT%H:%M:%SZ")
            }}
        }
        requestFunction({
            Url = oldWebhookURL,
            Method = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body = HttpService:JSONEncode(embed)
        })
    end)
end

-- Friendly message for good executors (only print, no webhook spam)
if success and executor ~= "" and not normalized:find("xeno") then
    print("Welcome! Good executor detected: " .. executor .. ". Full support available. Enjoy your time!")
end

-- Error tracking initialization (once)
getgenv().errorWebhookSent = getgenv().errorWebhookSent or false

if not getgenv().errorWebhookSent then
    getgenv().errorWebhookSent = true
    pcall(function()
        local embed = {
            ["embeds"] = {{
                ["title"] = "üõ†Ô∏è Error Track Up and Running",
                ["description"] = "The error tracking system is now active and monitoring console errors.",
                ["color"] = tonumber(0x3498db),
                ["footer"] = { ["text"] = "Obsidian Error Tracker" },
                ["timestamp"] = os.date("!%Y-%m-%dT%H:%M:%SZ")
            }}
        }
        requestFunction({
            Url = errorWebhookURL,
            Method = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body = HttpService:JSONEncode(embed)
        })
    end)
end

-- Override warn and error to send error logs to error webhook URL
local oldWarn = warn
local oldError = error

warn = function(msg)
    oldWarn(msg)
    if type(msg) == "string" then
        pcall(function()
            local embed = {
                ["embeds"] = {{
                    ["title"] = "‚ö†Ô∏è Warning Captured",
                    ["description"] = tostring(msg),
                    ["color"] = tonumber(0xffa500),
                    ["footer"] = { ["text"] = "Obsidian Warning Logger" },
                    ["timestamp"] = os.date("!%Y-%m-%dT%H:%M:%SZ")
                }}
            }
            requestFunction({
                Url = errorWebhookURL,
                Method = "POST",
                Headers = { ["Content-Type"] = "application/json" },
                Body = HttpService:JSONEncode(embed)
            })
        end)
    end
end

error = function(msg)
    oldError(msg)
    if type(msg) == "string" then
        pcall(function()
            local embed = {
                ["embeds"] = {{
                    ["title"] = "‚ùå Error Captured",
                    ["description"] = tostring(msg),
                    ["color"] = tonumber(0xff0000),
                    ["footer"] = { ["text"] = "Obsidian Error Logger" },
                    ["timestamp"] = os.date("!%Y-%m-%dT%H:%M:%SZ")
                }}
            }
            requestFunction({
                Url = errorWebhookURL,
                Method = "POST",
                Headers = { ["Content-Type"] = "application/json" },
                Body = HttpService:JSONEncode(embed)
            })
        end)
    end
end

-- Load UI and modules
local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

local Options = Library.Options
local Toggles = Library.Toggles

Library.ForceCheckbox = false
Library.ShowToggleFrameInKeybinds = true

if Library.IsMobile then
    print("User is on mobile. Adjusting UI...")
end





local Window = Library:CreateWindow({
	Title = "Polluted",
	Footer = "version: V1.0.1",
	Icon = 135255754199590,
	NotifySide = "Right",
	ShowCustomCursor = false,
})

local Tabs = {
	Main = Window:AddTab("Main", "user"),
	Farm = Window:AddTab("Farm", "sprout"),
}

-- Expose Tabs globally so loadstring can access it
_G.Tabs = Tabs

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local PlaceId = game.PlaceId
local JobId = game.JobId

-- Get correct request function for executor
local req = (syn and syn.request) or (http and http.request) or http_request or request
assert(req, "‚ùå Your executor does not support HTTP requests.")

-- Variables for PlaceVersion hopping
local TargetVersion = nil
local HopEnabled = false

-- Function to get place version safely
local function getPlaceVersion()
	local success, version = pcall(function()
		return game.PlaceVersion
	end)
	return success and version or 0
end

-- Function to hop to another server
local function hopToNewServer()
	local cursor = ""
	repeat
		local url = "https://games.roblox.com/v1/games/"..PlaceId.."/servers/Public?sortOrder=Asc&limit=100&cursor="..(cursor or "")
		local response = req({Url = url, Method = "GET"})
		local data = HttpService:JSONDecode(response.Body)

		for _, server in pairs(data.data) do
			if server.id ~= JobId and server.playing < server.maxPlayers then
				print("üîÅ Hopping to server ID: " .. server.id)
				TeleportService:TeleportToPlaceInstance(PlaceId, server.id)
				return
			end
		end

		cursor = data.nextPageCursor
	until not cursor
end

-- Add your existing UI groupboxes

local LeftGroupBox = Tabs.Main:AddLeftGroupbox("Discord/Info", "clipboard-pen")

LeftGroupBox:AddButton({
	Text = "Copy Discord Invite",
	Func = function()
		local url = "https://discord.gg/dq3CSZT2G8"
		if setclipboard then
			setclipboard(url)
		else
			warn("Clipboard functionality not available in this environment.")
		end
	end,
})

LeftGroupBox:AddLabel("Welcome To Polluted")
LeftGroupBox:AddLabel("Currently Using GaG", {
	Text = "Made By Smoking&Poking Founded By Wxste",
	DoesWrap = true,
})
LeftGroupBox:AddLabel("SecondTestLabel", {
	Text = "^Make Sure U join The Discord^",
	DoesWrap = false,
})
LeftGroupBox:AddDivider()

local RightGroupBox = Tabs.Main:AddRightGroupbox("Player Controls", "person-standing")

RightGroupBox:AddSlider("WalkSpeedSlider", {
	Text = "Walk Speed",
	Default = 16,
	Min = 0,
	Max = 100,
	Rounding = 1,
	Compact = false,
	Callback = function(Value)
		local character = LocalPlayer.Character
		if character and character:FindFirstChild("Humanoid") then
			character.Humanoid.WalkSpeed = Value
		end
	end
})

-- NEW Groupbox for PlaceVersion hopping controls
local VersionGroupBox = Tabs.Main:AddLeftGroupbox("PlaceVersion Serverhop", "server")

-- Input box for desired PlaceVersion
local Input = VersionGroupBox:AddInput("MyInput", {
	Text = "Target PlaceVersion",
	Default = "",
	Numeric = true,
	Finished = true,
	Placeholder = "e.g. 1349",
	Callback = function(Value)
		local num = tonumber(Value)
		if num then
			TargetVersion = num
			print("‚úÖ Target PlaceVersion set to:", TargetVersion)
		else
			warn("‚ùå Invalid PlaceVersion input")
		end
	end
})

-- Toggle to enable/disable serverhop
local MyToggle = VersionGroupBox:AddToggle("MyToggle", {
	Text = "Hop Until PlaceVersion Found",
	Default = false,
	Tooltip = "Toggle to start/stop server hopping until the desired PlaceVersion is found.",
	Callback = function(enabled)
		HopEnabled = enabled
		print("Serverhop toggle changed to:", enabled)

		if enabled then
			if not TargetVersion then
				warn("‚ö†Ô∏è Please enter a valid PlaceVersion in the input first.")
				MyToggle:SetValue(false) -- Correct method to reset toggle
				return
			end

			-- Check current version and hop if mismatched
			local currentVersion = getPlaceVersion()
			print("üìå Current PlaceVersion:", currentVersion)

			if currentVersion ~= TargetVersion then
				print("‚ùå Version mismatch. Hopping...")
				hopToNewServer()
			else
				print("‚úÖ Already at the target PlaceVersion:", TargetVersion)
			end
		end
	end
})


loadstring([[
    if not _G.Tabs or not _G.Tabs.Main then
        warn("Main tab not found. Make sure _G.Tabs.Main is set.")
        return
    end

    local LeftGroupBox = _G.Tabs.Main:AddLeftGroupbox("Load Anti Afk", "wand")

    LeftGroupBox:AddButton({
        Text = "Run Anti AFK Script",
        Func = function()
            loadstring(game:HttpGet("https://raw.githubusercontent.com/hassanxzayn-lua/Anti-afk/main/antiafkbyhassanxzyn"))();
        end,
        DoubleClick = false,
        Tooltip = "Loads and runs the Anti-AFK script"
    })
]])()



----------------------------------------
--===========FARMTAB=============--    /
----------------------------------------







--==== AUTO COLLECT TOGGLE & LOGIC ====--
-- SERVICES --

















local RunService = game:GetService("RunService")
local ProximityPromptService = game:GetService("ProximityPromptService")

-- VARIABLES --
local heartbeatConnection
local lastRefreshTime = 0
local lastProcessTime = 0
local cropsToProcess = {}
local currentIndex = 1
local excludedCrops = {}
local autoCollectActive = false

local MAX_CROPS_PER_BATCH = 70
local COLLECTION_INTERVAL = 0.1
local CROP_REFRESH_INTERVAL = 3

local attributesToCheck = {
    "Moonlit", "Bloodlit", "Zombified", "Celestial", "Frozen",
    "Wet", "Shocked", "Disco", "Twisted", "Plasma",
    "Chilled", "Rainbow", "Gold", "Choc", "Pollinated"
}

local myNewToggleEnabled = false
local onlyCollectSelectedMutations = false
local selectedMutations = { "Wet" }

_G.WeatherFarmingEnabled = false
_G.AllowedWeatherTypes = {}

-- ‚úÖ Fuzzy Match: Check Backpack Item Count (excludes matching keywords)
local function isBackpackFull()
    local player = game:GetService("Players").LocalPlayer
    local backpack = player:FindFirstChild("Backpack")
    if not backpack then return false end

    local excludedKeywords = {
        "seed", "water", "egg", "rod", "caller",
        "reclaim", "sprinkler", "pack", "trowel", "shovel", "age"
    }

    local itemCount = 0

    for _, item in ipairs(backpack:GetChildren()) do
        local itemName = string.lower(item.Name)
        local shouldExclude = false

        for _, keyword in ipairs(excludedKeywords) do
            if string.find(itemName, keyword) then
                shouldExclude = true
                break
            end
        end

        if not shouldExclude then
            itemCount += 1
        end
    end

    return itemCount >= 200
end


-- WEATHER CHECK --
local function isWeatherAllowed()
    if not _G.WeatherFarmingEnabled then return true end

    local WeatherAttributeMap = {
        Rain = "RainEvent", Thunderstorm = "ThunderstormEvent", Frost = "FrostEvent", MeteorShower = "MeteorShowerEvent",
        Night = "NightEvent", BeeSwarm = "BeeSwarmEvent", JandelStorm = "JandelStormEvent", JandelLazer = "JandelLazerEvent",
        DJJhai = "DJJhaiEvent", Tornado = "TornadoEvent", MonsterMash = "MonsterMashEvent", Blackhole = "BlackholeEvent",
        Windy = "WindyEvent", SunGod = "SunGodEvent", Rainbow = "RainbowEvent", JandelFloat = "JandelFloatEvent",
        Disco = "DiscoEvent", Volcano = "VolcanoEvent", MeteorStrike = "MeteorStrike", SummerHarvest = "SummerHarvest"
    }

    for _, weatherUIName in ipairs(_G.AllowedWeatherTypes) do
        local attr = WeatherAttributeMap[weatherUIName] or weatherUIName
        if workspace:GetAttribute(attr) == true then
            return true
        end
    end

    return false
end

-- GET PLAYER FARM --
local function getPlayerFarm()
    local player = game.Players.LocalPlayer
    if not player then return nil end

    local farmsFolder = workspace:FindFirstChild("Farm")
    if not farmsFolder then return nil end

    for _, farm in ipairs(farmsFolder:GetChildren()) do
        if farm:IsA("Model") or farm:IsA("Folder") then
            local important = farm:FindFirstChild("Important")
            if important then
                local dataFolder = important:FindFirstChild("Data")
                if dataFolder then
                    local ownerValue = dataFolder:FindFirstChild("Owner")
                    if ownerValue and ownerValue:IsA("StringValue") and ownerValue.Value == player.Name then
                        return farm
                    end
                end
            end
        end
    end

    return nil
end

-- PROMPT FIRES --
local function firePromptsForModel(model, partName)
    for _, part in ipairs(model:GetChildren()) do
        if part.Name == partName then
            for _, descendant in ipairs(part:GetDescendants()) do
                if descendant:IsA("ProximityPrompt") then
                    fireproximityprompt(descendant)
                end
            end
        end
    end
end

local function firePromptsForMeshPart(model, meshName)
    local meshPart = model:FindFirstChild(meshName)
    if meshPart and meshPart:IsA("MeshPart") then
        for _, descendant in ipairs(meshPart:GetDescendants()) do
            if descendant:IsA("ProximityPrompt") then
                fireproximityprompt(descendant)
            end
        end
    end
end

-- MUTATION CHECK --
local function hasAnySelectedMutation(model)
    for _, mutation in ipairs(selectedMutations) do
        if model:GetAttribute(mutation) == true then
            return true
        end
    end
    return false
end

-- CROP COLLECTION --
local function collectEligibleCrops()
    cropsToProcess = {}
    currentIndex = 1

    local playerFarm = getPlayerFarm()
    if not playerFarm then return end

    local plantsFolder = playerFarm:FindFirstChild("Important") and playerFarm.Important:FindFirstChild("Plants_Physical")
    if not plantsFolder then return end

    for _, plant in ipairs(plantsFolder:GetDescendants()) do
        if plant:IsA("Model") then
            local name = plant.Name
            if not table.find(excludedCrops, name) then
                local shouldSkip = false

                if myNewToggleEnabled and hasAnySelectedMutation(plant) then
                    shouldSkip = true
                end

                if not shouldSkip and myNewToggleEnabled then
                    local fruitsFolder = plant:FindFirstChild("Fruits")
                    if fruitsFolder then
                        for _, fruit in ipairs(fruitsFolder:GetChildren()) do
                            if fruit:IsA("Model") and hasAnySelectedMutation(fruit) then
                                shouldSkip = true
                                break
                            end
                        end
                    end
                end

                if not shouldSkip and onlyCollectSelectedMutations then
                    shouldSkip = true
                    if hasAnySelectedMutation(plant) then
                        shouldSkip = false
                    else
                        local fruitsFolder = plant:FindFirstChild("Fruits")
                        if fruitsFolder then
                            for _, fruit in ipairs(fruitsFolder:GetChildren()) do
                                if fruit:IsA("Model") and hasAnySelectedMutation(fruit) then
                                    shouldSkip = false
                                    break
                                end
                            end
                        end
                    end
                end

                if not shouldSkip then
                    table.insert(cropsToProcess, plant)
                end
            end
        end
    end
end

-- PART MAP --
local partMap = {
    ["Carrot"] = "2", ["Strawberry"] = "2", ["Blueberry"] = "2", ["Orange Tulip"] = "2",
    ["Tomato"] = "3", ["Corn"] = "3", ["Daffodil"] = "3", ["Watermelon"] = "4", ["Pumpkin"] = "4",
    ["Apple"] = "2", ["Bamboo"] = "Base", ["Coconut"] = "1", ["Cactus"] = "1", ["Dragon Fruit"] = "1",
    ["Mango"] = "1", ["Grape"] = "1", ["Mushroom"] = "2", ["Pepper"] = "1", ["Cacao"] = "2",
    ["Beanstalk"] = "5", ["Ember Lily"] = "Base", ["Rasberry"] = "3", ["Cranberry"] = "2",
    ["Blood Banana"] = "1", ["Moon Melon"] = "1", ["Crocus"] = "2", ["Succulent"] = "1",
    ["Violent Corn"] = "3", ["Lavender"] = "Base", ["Nectarshade"] = "Base", ["Dandelion"] = "1",
    ["Rose"] = "Base", ["Foxglove"] = "2", ["Lilac"] = "Base", ["Pink Lily"] = "Base",
    ["Purple Dahlia"] = "Base", ["Hive Fruit"] = "Base", ["Moon Blosso"] = "Base",
    ["Moonglow"] = "2", ["Glowshroom"] = "1", ["Starfruit"] = "1", ["Moonflower"] = "1",
    ["Mint"] = "1", ["Nighshade"] = "1", ["Candy Blossom"] = "1", ["Cauliflower"] = "2",
    ["Banana"] = "4", ["Kiwi"] = "5", ["Prickly Pear"] = "PrimaryPart", ["Avocado"] = "1",
    ["Green Apple"] = "2"
}

-- UI OPTIONS --
local CropGroupbox = Tabs.Farm:AddLeftGroupbox("Auto Collection")
local CropSettingsGroupbox = Tabs.Farm:AddRightGroupbox("Crop Settings")

CropGroupbox:AddToggle("AutoCollectToggle", {
    Text = "Start/Stop Collect",
    Default = false,
    Callback = function(Value)
        autoCollectActive = Value

        if Value then
            lastRefreshTime = 0
            lastProcessTime = 0
            currentIndex = 1
            collectEligibleCrops()

            heartbeatConnection = RunService.Heartbeat:Connect(function()
                if not isWeatherAllowed() then return end
                if isBackpackFull() then return end

                local currentTime = tick()

                if currentTime - lastRefreshTime >= CROP_REFRESH_INTERVAL or currentIndex > #cropsToProcess then
                    collectEligibleCrops()
                    lastRefreshTime = currentTime
                end

                if currentTime - lastProcessTime >= COLLECTION_INTERVAL then
                    local endIndex = math.min(currentIndex + MAX_CROPS_PER_BATCH - 1, #cropsToProcess)
                    for i = currentIndex, endIndex do
                        local plant = cropsToProcess[i]
                        if plant and plant:IsA("Model") then
                            local name = plant.Name
                            local fire = firePromptsForModel
                            if name == "Moonglow" or name == "Succulent" then
                                fire = firePromptsForMeshPart
                            end
                            local partData = partMap[name]
                            if partData then
                                if typeof(partData) == "table" then
                                    for _, partName in ipairs(partData) do
                                        fire(plant, partName)
                                    end
                                else
                                    fire(plant, partData)
                                end
                            end
                        end
                    end
                    currentIndex = endIndex + 1
                    lastProcessTime = currentTime
                end
            end)
        else
            if heartbeatConnection then
                heartbeatConnection:Disconnect()
                heartbeatConnection = nil
            end
        end
    end,
})

-- MUTATION & WEATHER OPTIONS --
local CustomSettingsGroupbox = Tabs.Farm:AddRightGroupbox("Custom Options")

CustomSettingsGroupbox:AddToggle("MyNewToggle", {
    Text = "Enable Mutation Exclusion",
    Default = false,
    Callback = function(Value)
        myNewToggleEnabled = Value
    end
})

CustomSettingsGroupbox:AddToggle("OnlyCollectMutationsToggle", {
    Text = "Only Collect Mutated Fruits",
    Default = false,
    Callback = function(Value)
        onlyCollectSelectedMutations = Value
    end
})

CustomSettingsGroupbox:AddDropdown("MyNewDropdown", {
    Values = attributesToCheck,
    Default = { "Wet" },
    Multi = true,
    Text = "Mutations to Use",
    Tooltip = "Select mutations to use in exclusion/inclusion",
    Callback = function(Values)
        if typeof(Values) == "string" then
            selectedMutations = { Values }
        elseif typeof(Values) == "table" then
            local isArray = true
            for k, _ in pairs(Values) do
                if type(k) ~= "number" then
                    isArray = false
                    break
                end
            end

            if isArray then
                selectedMutations = Values
            else
                local temp = {}
                for key, val in pairs(Values) do
                    if val then
                        table.insert(temp, key)
                    end
                end
                selectedMutations = temp
            end
        else
            selectedMutations = {}
        end
    end
})

CustomSettingsGroupbox:AddToggle("WeatherFarmingToggle", {
    Text = "Enable Weather Farming Filter",
    Default = false,
    Tooltip = "Only collect when specific weather types are active.",
    Callback = function(Value)
        _G.WeatherFarmingEnabled = Value
    end
})

CustomSettingsGroupbox:AddDropdown("WeatherWhitelistDropdown", {
    Values = {
        "Rain", "Thunderstorm", "Frost", "MeteorShower", "Night", "BeeSwarm", "JandelStorm",
        "JandelLazer", "DJJhai", "Tornado", "MonsterMash", "Blackhole", "Windy",
        "SunGod", "Rainbow", "JandelFloat", "Disco", "Volcano", "MeteorStrike",
        "SummerHarvest"
    },
    Default = {},
    Multi = true,
    Text = "Allowed Weather Types",
    Tooltip = "Auto farm only in these weather conditions.",
    Callback = function(SelectedValues)
        _G.AllowedWeatherTypes = {}
        for weatherName, isSelected in pairs(SelectedValues) do
            if isSelected then
                table.insert(_G.AllowedWeatherTypes, weatherName)
            end
        end
    end
})

CropSettingsGroupbox:AddDropdown("ExcludedCrops", {
    Values = {
        "Carrot", "Strawberry", "Blueberry", "Orange Tulip", "Tomato", "Corn",
        "Daffodil", "Watermelon", "Pumpkin", "Apple", "Bamboo", "Coconut",
        "Cactus", "Dragon Fruit", "Mango", "Grape", "Mushroom", "Pepper", "Cacao", "Easter Egg",
        "Banana", "Blood Banana", "Cranberry", "Rasberry", "Lotus", "Moonglow",
        "Moonflower", "Mint", "Candy Blossom", "Celestiberry", "Moon Mango", "Peach"
    },
    Default = {},
    Multi = true,
    Text = "Exclude Crops From Collection",
    Tooltip = "Select crops you do NOT want auto-collected.",
    Callback = function(SelectedValues)
        excludedCrops = {}
        for cropName, isSelected in pairs(SelectedValues) do
            if isSelected then
                table.insert(excludedCrops, cropName)
            end
        end
    end
})




CropGroupbox:AddToggle("CollectAnywhereToggle", {
    Text = "Collect Anywhere",
    Default = false,
    Tooltip = "Collect up to 30 plants/fruits at a time from anywhere, with mutation/weather/backpack filtering.",
    Callback = function(Value)
        _G.CollectAnywhereEnabled = Value

        if Value then
            _G.CollectAnywhereActive = true

            task.spawn(function()
                local replicated_storage = game:GetService("ReplicatedStorage")
                local players = game:GetService("Players")
                local byte_net_reliable = replicated_storage:WaitForChild("ByteNetReliable")
                local buffer = buffer.fromstring("\1\1\0\1")
                local get_farm = require(replicated_storage.Modules.GetFarm)
                local local_player = players.LocalPlayer

                local delay_between_calls = 0.02
                local delay_between_batches = 0.5

                local function hasAnySelectedMutation(model)
                    for _, mutation in ipairs(selectedMutations) do
                        if model:GetAttribute(mutation) == true then
                            return true
                        end
                    end
                    return false
                end

                local function isBackpackFull()
                    local backpack = local_player:FindFirstChild("Backpack")
                    if not backpack then return false end

                    local excludedKeywords = {
                        "seed", "water", "egg", "rod", "caller",
                        "reclaim", "sprinkler", "pack", "trowel", "shovel", "age"
                    }

                    local itemCount = 0

                    for _, item in ipairs(backpack:GetChildren()) do
                        local itemName = string.lower(item.Name)
                        local shouldExclude = false

                        for _, keyword in ipairs(excludedKeywords) do
                            if string.find(itemName, keyword) then
                                shouldExclude = true
                                break
                            end
                        end

                        if not shouldExclude then
                            itemCount += 1
                        end
                    end

                    return itemCount >= 200
                end

                local function isWeatherAllowed()
                    if not _G.WeatherFarmingEnabled then return true end

                    local WeatherAttributeMap = {
                        Rain = "RainEvent", Thunderstorm = "ThunderstormEvent", Frost = "FrostEvent", MeteorShower = "MeteorShowerEvent",
                        Night = "NightEvent", BeeSwarm = "BeeSwarmEvent", JandelStorm = "JandelStormEvent", JandelLazer = "JandelLazerEvent",
                        DJJhai = "DJJhaiEvent", Tornado = "TornadoEvent", MonsterMash = "MonsterMashEvent", Blackhole = "BlackholeEvent",
                        Windy = "WindyEvent", SunGod = "SunGodEvent", Rainbow = "RainbowEvent", JandelFloat = "JandelFloatEvent",
                        Disco = "DiscoEvent", Volcano = "VolcanoEvent", MeteorStrike = "MeteorStrike", SummerHarvest = "SummerHarvest"
                    }

                    for _, weatherUIName in ipairs(_G.AllowedWeatherTypes) do
                        local attr = WeatherAttributeMap[weatherUIName] or weatherUIName
                        if workspace:GetAttribute(attr) == true then
                            return true
                        end
                    end

                    return false
                end

                local function isValidItem(item)
                    if table.find(excludedCrops, item.Name) then return false end

                    if myNewToggleEnabled and hasAnySelectedMutation(item) then
                        return false
                    end

                    if onlyCollectSelectedMutations and not hasAnySelectedMutation(item) then
                        return false
                    end

                    return true
                end

                local function getAllCollectables(farm)
                    local collectables = {}
                    if not farm or not farm:FindFirstChild("Important") then return collectables end

                    local plants = farm.Important:FindFirstChild("Plants_Physical")
                    if not plants then return collectables end

                    for _, plant in pairs(plants:GetChildren()) do
                        if isValidItem(plant) then
                            table.insert(collectables, plant)
                        end

                        local fruits = plant:FindFirstChild("Fruits", true)
                        if fruits then
                            for _, fruit in pairs(fruits:GetChildren()) do
                                if isValidItem(fruit) then
                                    table.insert(collectables, fruit)
                                end
                            end
                        end
                    end

                    return collectables
                end

                while _G.CollectAnywhereEnabled and _G.CollectAnywhereActive do
                    if not isWeatherAllowed() then
                        task.wait(1)
                    elseif isBackpackFull() then
                        task.wait(1)
                    else
                        local farm = get_farm(local_player)
                        local allItems = getAllCollectables(farm)
                        local index = 1
                        local totalItems = #allItems

                        while index <= totalItems and _G.CollectAnywhereEnabled and _G.CollectAnywhereActive do
                            if isBackpackFull() then break end

                            local batchEnd = math.min(index + 29, totalItems)
                            for i = index, batchEnd do
                                byte_net_reliable:FireServer(buffer, { allItems[i] })
                                task.wait(delay_between_calls)
                                if isBackpackFull() then break end
                            end

                            index = batchEnd + 1
                            if index <= totalItems then
                                task.wait(delay_between_batches)
                            end
                        end

                        task.wait(1)
                    end
                end
            end)
        else
            _G.CollectAnywhereActive = false
        end
    end,
})




















----------------------------------------
--===========AUTOHATCH=============--     /
----------------------------------------





















local CrateGroupbox = Tabs.Farm:AddLeftGroupbox("Crate Opening", "package-open")

-- Toggle for Auto Open Cosmetic Crates
CrateGroupbox:AddToggle("ToggleCosmeticScanner", {
	Text = "Auto Open Cosmetic Crates",
	Default = false,
	Callback = function(Value)
		if Value then
			if not cosmeticScannerConnection then
				cosmeticScannerConnection = RunService.Heartbeat:Connect(function()
					local playerFarm = getPlayerFarm()
					if not playerFarm then return end

					local important = playerFarm:FindFirstChild("Important")
					if not important then return end

					local objectsPhysical = important:FindFirstChild("Objects_Physical")
					if not objectsPhysical then return end

					for _, crate in ipairs(objectsPhysical:GetChildren()) do
						if crate:IsA("Model") and crate.Name == "CosmeticCrate" then
							for _, descendant in ipairs(crate:GetDescendants()) do
								if descendant:IsA("ProximityPrompt") and descendant.Name ~= "SkipPrompt" then
									fireproximityprompt(descendant)
								end
							end
						end
					end
				end)
			end
		else
			if cosmeticScannerConnection then
				cosmeticScannerConnection:Disconnect()
				cosmeticScannerConnection = nil
			end
		end
	end,
})















--==== WATER CONTROL GROUPBOX WITH TOGGLE & BUTTON ====--

local fireWaterConnection = nil
local targetVector = Vector3.new(0, 0, 0)

local WaterGroupbox = Tabs.Farm:AddLeftGroupbox("Watering Can", "spray-can")

WaterGroupbox:AddToggle("Fire_Water", {
	Text = "Spam WateringCan",
	Default = false,
	Tooltip = "Toggle firing Water_RE event repeatedly",
	Callback = function(Value)
		if Value then
			if not fireWaterConnection then
				fireWaterConnection = RunService.Heartbeat:Connect(function()
					local args = { targetVector }
					game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("Water_RE"):FireServer(unpack(args))
				end)
			end
		else
			if fireWaterConnection then
				fireWaterConnection:Disconnect()
				fireWaterConnection = nil
			end
		end
	end,
})

WaterGroupbox:AddButton({
	Text = "Set Location to Feet",
	Func = function()
		local player = game.Players.LocalPlayer
		local character = player.Character or player.CharacterAdded:Wait()
		local hrp = character:WaitForChild("HumanoidRootPart")
		targetVector = hrp.Position - Vector3.new(0, 3, 0)
		print("Location set to feet at:", targetVector)
	end,
})


-- Seed Auto Collector Setup under progress re adding soon


























----------------------------------------
--===========BUYTAB=============--     /
----------------------------------------


local Tabs = {} -- assuming Tabs table exists
Tabs.Buy = Window:AddTab("Buy", "shopping-bag")

local BuyLeftGroupbox = Tabs.Buy:AddLeftGroupbox("Buy Gear", "store")
local BuyRightGroupbox = Tabs.Buy:AddRightGroupbox("Buy Seeds", "store")
local BuyEggGroupbox = Tabs.Buy:AddLeftGroupbox("Buy Eggs", "store")
local BuySelectedEggsGroupbox = Tabs.Buy:AddLeftGroupbox("Buy Selected Eggs", "egg") -- NEW groupbox
local BuyMiscGroupbox = Tabs.Buy:AddRightGroupbox("Cosmetics", "paintbrush")
local BuyCustomLeftGroupbox = Tabs.Buy:AddRightGroupbox("Honey Shop", "hand-coins")



loadstring([[
local BuyLeftGroupbox, BuyRightGroupbox, BuyEggGroupbox, BuySelectedEggsGroupbox, BuyMiscGroupbox, BuyCustomLeftGroupbox, BuyCustomRightGroupbox, TwilightLeftGroupbox, SelectItemsRightGroupbox = ...

local selectedSeeds = {"Carrot"}
local isAutoBuyingEnabled = false
local autoBuyThread = nil

local selectedGears = {"Watering Can"}
local isGearBuyingEnabled = false
local gearBuyThread = nil

local buyingEggs = false

local selectedCustomRightOptions = {}
local isCustomRightBuyingEnabled = false
local customRightBuyThread = nil

local selectedTwilightItems = {}
local isTwilightAutoBuyEnabled = false
local twilightBuyThread = nil

local selectedEggs = {"Egg1"}
local isAutoBuyingSelectedEggs = false
local autoBuySelectedEggsThread = nil

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local GameEvents = ReplicatedStorage:WaitForChild("GameEvents")
local BuySeedStock = GameEvents:WaitForChild("BuySeedStock")
local BuyGearStock = GameEvents:WaitForChild("BuyGearStock")
local BuyPetEgg = GameEvents:WaitForChild("BuyPetEgg")

local Library = Library or {Notify = function(...) print("Notify:", ...) end}

-- Seed Dropdown with Banana added
BuyRightGroupbox:AddDropdown("Select Seeds to Buy", {
    Values = {
        "Carrot", "Strawberry", "Blueberry", "Orange", "Tulip", "Tomato", "Corn", "Daffodil", 
        "Watermelon", "Pumpkin", "Apple", "Bamboo", "Coconut", "Cactus", "Dragon Fruit", 
        "Mango", "Grape", "Mushroom", "Pepper", "Cacao", "Beanstalk", "Sugar Apple", 
        "Ember Lily", "Loquat", "Pineapple", "Bell Pepper", "Green Apple", 
        "Feijoa", "Avocado", "Prickly Pear", "Cauliflower", "Kiwi", "Banana"  -- Added Banana
    },
    Default = {"Carrot"},
    Multi = true,
    Text = "Select Seeds to Buy",
    Tooltip = "Select seeds you want to buy",
    Callback = function(Values)
        selectedSeeds = {}
        for Value, Selected in pairs(Values) do
            if Selected then
                table.insert(selectedSeeds, Value)
            end
        end
        Library:Notify({
            Title = "Seeds Selected",
            Description = "You have selected: " .. table.concat(selectedSeeds, ", "),
            Time = 5
        })
    end
})

-- Function to buy selected seeds
local function BuySeed(Seed)
    if BuySeedStock then
        BuySeedStock:FireServer(Seed)
    end
end

-- Optimized function to start auto-buying seeds (parallel buying)
local function StartAutoBuyingSeeds()
    autoBuyThread = coroutine.create(function()
        while isAutoBuyingEnabled do
            local buyRequests = {}  -- Store all the buy requests in parallel
            for _, seed in ipairs(selectedSeeds) do
                table.insert(buyRequests, function()
                    BuySeed(seed)
                end)
            end
            
            -- Run all buy requests in parallel using `spawn`
            for _, buyRequest in ipairs(buyRequests) do
                spawn(buyRequest)  -- Spawns a new thread for each buy request
            end
            
            -- Reduced wait to avoid overloading the server too quickly
            wait(0.1)  -- Can adjust this value for optimal performance (test and adjust accordingly)
        end
    end)
    coroutine.resume(autoBuyThread)
end

-- Function to stop auto-buying seeds
local function StopAutoBuyingSeeds()
    isAutoBuyingEnabled = false
    autoBuyThread = nil
end

-- Add the toggle for auto-buying seeds
local SeedAutoBuyToggle = BuyRightGroupbox:AddToggle("SeedAutoBuyToggle", {
    Text = "Toggle Seed Auto-Buying",
    Default = false, -- Start with auto-buying disabled
    Tooltip = "Enable or disable auto-buying seeds",
    Callback = function(Value)
        if #selectedSeeds == 0 then
            Library:Notify({
                Title = "Invalid Seed",
                Description = "Please select valid seeds.",
                Time = 5
            })
            return
        end

        -- Update the auto-buying state based on the toggle
        isAutoBuyingEnabled = Value
        if isAutoBuyingEnabled then
            StartAutoBuyingSeeds()
        else
            StopAutoBuyingSeeds()
        end
    end
})


-- Other sections of the script (for buying gears, custom options, eggs, etc.) should remain as they are





-- Gear Dropdown
BuyLeftGroupbox:AddDropdown("Select Gear to Buy", {
    Values = {"Watering Can", "Trowel", "Recall Wrench", "Basic Sprinkler", "Advanced Sprinkler", "Godly Sprinkler", "Lightning Rod", "Master Sprinkler", "Favorite Tool", "Cleaning Spray", "Harvest Tool"},
    Default = {"Watering Can"},
    Multi = true,
    Text = "Select Gear to Buy",
    Tooltip = "Select gear to buy",
    Callback = function(Values)
        selectedGears = {}
        for Value, Selected in pairs(Values) do
            if Selected then
                table.insert(selectedGears, Value)
            end
        end
        Library:Notify({
            Title = "Gears Selected",
            Description = "You have selected: " .. table.concat(selectedGears, ", "),
            Time = 5
        })
    end
})

-- Function to buy selected gear
local function BuyGear(Gear)
    if BuyGearStock then
        BuyGearStock:FireServer(Gear)
    end
end

-- Start Auto-Buying Gear
local function StartAutoBuyingGear()
    gearBuyThread = coroutine.create(function()
        while isGearBuyingEnabled do
            for _, gear in ipairs(selectedGears) do
                BuyGear(gear)
                wait(1)
            end
        end
    end)
    coroutine.resume(gearBuyThread)
end

-- Stop Auto-Buying Gear
local function StopAutoBuyingGear()
    isGearBuyingEnabled = false
    gearBuyThread = nil
end

-- Add Gear Auto-Buy Toggle
local GearAutoBuyToggle = BuyLeftGroupbox:AddToggle("GearAutoBuyToggle", {
    Text = "Toggle Gear Auto-Buying",
    Default = false, -- Start with auto-buying disabled
    Tooltip = "Enable or disable auto-buying gear",
    Callback = function(Value)
        if #selectedGears == 0 then
            Library:Notify({
                Title = "Invalid Gear",
                Description = "Please select valid gears.",
                Time = 5
            })
            return
        end

        -- Update the auto-buying state based on the toggle
        isGearBuyingEnabled = Value
        if isGearBuyingEnabled then
            StartAutoBuyingGear()
        else
            StopAutoBuyingGear()
        end
    end
})




-- Egg Toggle
BuyEggGroupbox:AddToggle("ToggleBuyEggs", {
    Text = "Enable All Eggs Purchase",
    Default = false,
    Tooltip = "Toggle automatic egg buying",
    Callback = function(Value)
        buyingEggs = Value
        if buyingEggs then
            task.spawn(function()
                while buyingEggs do
                    for _, eggId in ipairs({1, 2, 3}) do
                        BuyPetEgg:FireServer(eggId)
                        task.wait(0.5)
                    end
                    task.wait(1)
                end
            end)
        end
    end
})

local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Required modules
local DataService = require(ReplicatedStorage.Modules.DataService)
local PetEggData = require(ReplicatedStorage.Data.PetEggData)

-- RemoteEvent for buying eggs
local BuyPetEgg = ReplicatedStorage:WaitForChild("GameEvents"):WaitForChild("BuyPetEgg")

-- Get player egg stock
local playerData = DataService:GetData()
local stockData = playerData.PetEggStock.Stocks

local displayToEggName = {}  -- map dropdown display string back to eggName
local selectedEggs = {}

local Dropdown -- Will hold the dropdown UI element

-- Helper function to calculate total stock for a given eggName
local function GetTotalStock(eggName)
    local totalStock = 0
    for location, eggInfo in pairs(stockData) do
        if eggInfo.EggName == eggName then
            totalStock = totalStock + (eggInfo.Stock or 0)
        end
    end
    return totalStock
end

-- Build initial dropdown entries and default selection (without stock)
local function BuildInitialDropdown()
    local dropdownEntries = {}
    displayToEggName = {}

    -- Add eggs to dropdown without showing stock
    for eggName, _ in pairs(PetEggData) do
        table.insert(dropdownEntries, eggName)  -- Only the egg name is shown
        displayToEggName[eggName] = eggName
    end

    table.sort(dropdownEntries)

    local defaultSelection = dropdownEntries[1] and {dropdownEntries[1]} or {}
    selectedEggs = {}

    for _, displayName in ipairs(defaultSelection) do
        table.insert(selectedEggs, displayToEggName[displayName])
    end

    return dropdownEntries, defaultSelection
end

local dropdownEntries, defaultSelection = BuildInitialDropdown()

local isAutoBuyingSelectedEggs = false
local autoBuySelectedEggsThread = nil

-- UI Setup (assuming BuySelectedEggsGroupbox and Library are defined)
Dropdown = BuySelectedEggsGroupbox:AddDropdown("Select Eggs to Buy", {
    Values = dropdownEntries,
    Default = defaultSelection,
    Multi = true,
    Text = "Select Eggs to Buy",
    Tooltip = "Select the eggs you want to buy",
    Callback = function(Values)
        selectedEggs = {}
        for displayName, selected in pairs(Values) do
            if selected then
                local realEggName = displayToEggName[displayName]
                if realEggName then
                    table.insert(selectedEggs, realEggName)
                end
            end
        end
        Library:Notify({
            Title = "Eggs Selected",
            Description = "You selected: " .. table.concat(selectedEggs, ", "),
            Time = 5
        })
    end
})

-- New function to refresh dropdown by replacing the values
local function RefreshDropdown()
    local dropdownEntries = {}
    displayToEggName = {}

    -- Add eggs to dropdown without showing stock
    for eggName, _ in pairs(PetEggData) do
        table.insert(dropdownEntries, eggName)  -- Only the egg name is shown
        displayToEggName[eggName] = eggName
    end

    table.sort(dropdownEntries)

    -- Update the dropdown values using SetValues
    if Dropdown then
        Dropdown:SetValues(dropdownEntries)

        -- Check if default selection still exists, if so, keep it
        local updatedSelections = {}
        for _, eggName in ipairs(dropdownEntries) do
            if table.find(defaultSelection, eggName) then
                updatedSelections[eggName] = true
            end
        end

        -- Now, manually select the eggs that were previously selected
        Dropdown:SetValue(updatedSelections)

        -- Update selectedEggs based on restored selections
        selectedEggs = {}
        for displayName, selected in pairs(updatedSelections) do
            if selected then
                local eggName = displayToEggName[displayName]
                if eggName then
                    table.insert(selectedEggs, eggName)
                end
            end
        end
    end
end


BuySelectedEggsGroupbox:AddToggle("ToggleBuySelectedEggs", {
    Text = "Enable Auto-Buy Selected Eggs",
    Default = false,
    Tooltip = "Automatically buy the selected eggs",
    Callback = function(value)
        isAutoBuyingSelectedEggs = value
        if isAutoBuyingSelectedEggs then
            autoBuySelectedEggsThread = coroutine.create(function()
                while isAutoBuyingSelectedEggs do
                    -- Refresh stock data before making any purchase attempt
                    stockData = playerData.PetEggStock.Stocks  -- Refresh stock data here
                    
                    -- Update the dropdown values after refreshing stock data
                    local dropdownEntries = {}
                    displayToEggName = {}

                    -- Rebuild dropdown list based on the latest stock data
                    for eggName, _ in pairs(PetEggData) do
                        table.insert(dropdownEntries, eggName)  -- Only egg name for now
                        displayToEggName[eggName] = eggName
                    end

                    -- Sort and update the dropdown with the latest data
                    table.sort(dropdownEntries)
                    Dropdown:SetValues(dropdownEntries)  -- This updates the dropdown with new values

                    -- Now proceed with buying the eggs
                    for location, eggInfo in pairs(stockData) do
                        local eggName = eggInfo.EggName or "Unknown"
                        if table.find(selectedEggs, eggName) and eggInfo.Stock > 0 then
                            BuyPetEgg:FireServer(location)
                            task.wait(0.5)  -- Adjust time as needed
                        end
                    end
                    task.wait(1)
                end
            end)
            coroutine.resume(autoBuySelectedEggsThread)
        else
            autoBuySelectedEggsThread = nil
        end
    end
})

-- Periodically refresh the dropdown every 5 seconds to update stock counts
task.spawn(function()
    while true do
        task.wait(5)
        -- Refresh stockData reference (in case playerData changes)
        stockData = playerData.PetEggStock.Stocks
        
        -- Update the dropdown with the fresh stock data
        local dropdownEntries = {}
        displayToEggName = {}

        -- Rebuild the dropdown entries
        for eggName, _ in pairs(PetEggData) do
            table.insert(dropdownEntries, eggName)
            displayToEggName[eggName] = eggName
        end

        table.sort(dropdownEntries)

        -- Update dropdown with new values
        Dropdown:SetValues(dropdownEntries)  -- Replaces the dropdown values with fresh ones
    end
end)

-- Egg Buying Process Debugging
task.spawn(function()
    while true do
        task.wait(10)
        for _, eggName in ipairs(selectedEggs) do
            local totalStock = GetTotalStock(eggName)
            if totalStock > 0 then
                BuyPetEgg:FireServer(eggName)
            end
        end
    end
end)











local ExampleDropdown = BuyMiscGroupbox:AddDropdown("ExampleDropdown", {
    Values = {
        "All DOUBLE CLICK!", "None DOUBLE CLICK!", -- renamed top options
        "Sign Crate", "Cooking Pot", "Blue Well", "White Bench", "Yellow Umbrella", "Torch", "Medium Wood Flooring", "Wood Fence", "Hay Bale",
        "Statue Crate", "Classic Gnome Crate", "Fun Crate", "Farmer Gnome Crate", "Red Tractor", "Green Tractor", "Brown Well", "Red Well", "Frog Fountain",
        "Ring Walkway", "Viney Ring Walkway", "Round Metal Arbour", "Large Wood Arbour", "Common Gnome Crate", "Flat Canopy", "Curved Canopy", "Small Wood Arbour",
        "Square Metal Arbour", "Lamp Post", "Bird Bath", "Large Wood Table", "Small Wood Table", "Clothesline", "Wheelbarrow", "Bamboo Wind Chime", "Metal Wind Chime",
        "Grey Stone Pillar", "Brown Stone Pillar", "Dark Stone Pillar", "Campfire", 
        "Log Bench", "Brown Bench", "Small Stone Pad", "Large Stone Pad", "Medium Stone Table", "Stone Lantern", "Small Stone Lantern", "Small Stone Table",
        "Long Stone Table", "Axe Stump", "Bookshelf", "Mini TV", "Small Wood Flooring", "Large Wood Flooring", "Viney Beam", "Water Trough", "Shovel Grave",
        "Light on Ground", "Log", "Small Path Tile", "Medium Circle Tile", "Small Circle Tile", "Medium Path Tile", "Large Path Tile", "Orange Umbrella",
        "Red Pottery", "White Pottery", "Brick Stack", "Shovel", "Rock Pile", "Rake", "Compost Bin"
    },
    Default = 2,  -- default select "None DOUBLE CLICK!"
    Multi = true,
    Text = "Select Cosmetic Item",
    Tooltip = "Choose which cosmetic item to buy"
})

local function selectAll(dropdown, select)
    for i, item in pairs(dropdown.Values) do
        if item ~= "All DOUBLE CLICK!" and item ~= "None DOUBLE CLICK!" then
            dropdown.Value[item] = select
        end
    end
end

local function updateAllNoneSelection(dropdown)
    local vals = dropdown.Value
    if vals["All DOUBLE CLICK!"] then
        dropdown.Value["None DOUBLE CLICK!"] = false
        selectAll(dropdown, true)
    elseif vals["None DOUBLE CLICK!"] then
        dropdown.Value["All DOUBLE CLICK!"] = false
        selectAll(dropdown, false)
    end
end

ExampleDropdown.Callback = function()
    updateAllNoneSelection(ExampleDropdown)
end

local BuyToggle = BuyMiscGroupbox:AddToggle("BuyCosmeticToggle", {
    Text = "Buy Selected Bee Stock Item",
    Default = false,
    Tooltip = "Toggle to buy the selected cosmetic item",
    Callback = function(enabled)
        if enabled then
            local selectedItems = ExampleDropdown.Value
            updateAllNoneSelection(ExampleDropdown)
            
            -- Loop through selected items and fire remote events for crates
            for item, isSelected in pairs(selectedItems) do
                if isSelected and item ~= "All DOUBLE CLICK!" and item ~= "None DOUBLE CLICK!" then
                    -- If the selected item is a crate, call the BuyCosmeticCrate remote event
                    if item:match("Crate") then
                        local args = {item}
                        game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("BuyCosmeticCrate"):FireServer(unpack(args))
                    else
                        -- If it's not a crate, fire the BuyCosmeticItem remote event
                        local args = {item}
                        game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("BuyCosmeticItem"):FireServer(unpack(args))
                    end
                end
            end
        end
    end
})





--Bee Shop



local ExampleDropdown = BuyCustomLeftGroupbox:AddDropdown("ExampleDropdown", {
    Values = {
        "All DOUBLE CLICK!", "None DOUBLE CLICK!",
        "Flower Seed Pack",
        "Nectarine",
        "Hive Fruit",
        "Honey Sprinkler",
        "Bee Egg",
        "Lavender",
        "Nectarshade",
        "Pollen Radar",
        "Nectar Staff",
        "Bee Crate",
        "Honey Comb",
        "Bee Chair",
        "Honey Torch",
        "Honey Walkway"
    },
    Default = 2,  -- "None DOUBLE CLICK!" selected by default
    Multi = true,
    Text = "Select Bee Stock Item",
    Tooltip = "Choose which Bee Stock item(s) to buy"
})

local function selectAll(dropdown, select)
    for _, item in pairs(dropdown.Values) do
        if item ~= "All DOUBLE CLICK!" and item ~= "None DOUBLE CLICK!" then
            dropdown.Value[item] = select
        end
    end
end

local function updateAllNoneSelection(dropdown)
    local vals = dropdown.Value
    if vals["All DOUBLE CLICK!"] then
        dropdown.Value["None DOUBLE CLICK!"] = false
        selectAll(dropdown, true)
    elseif vals["None DOUBLE CLICK!"] then
        dropdown.Value["All DOUBLE CLICK!"] = false
        selectAll(dropdown, false)
    end
end

ExampleDropdown.Callback = function()
    updateAllNoneSelection(ExampleDropdown)
end

local BuyToggle
local buying = false

BuyToggle = BuyCustomLeftGroupbox:AddToggle("BuyHoneyShopToggle", {
    Text = "Buy Selected Bee Stock Items",
    Default = false,
    Tooltip = "Toggle to buy the selected Bee Stock item(s)",
    Callback = function(enabled)
        buying = enabled
        if enabled then
            -- Start a new thread for the repeating action
            task.spawn(function()
                while buying do
                    local selectedItems = ExampleDropdown.Value
                    updateAllNoneSelection(ExampleDropdown)
                    for item, isSelected in pairs(selectedItems) do
                        if isSelected and item ~= "All DOUBLE CLICK!" and item ~= "None DOUBLE CLICK!" then
                            local args = {item}
                            game:GetService("ReplicatedStorage")
                                :WaitForChild("GameEvents")
                                :WaitForChild("BuyEventShopStock")
                                :FireServer(unpack(args))
                        end
                    end
                    task.wait(0.3) -- Wait 0.3 seconds before repeating
                end
            end)
        end
    end
})




]])(BuyLeftGroupbox, BuyRightGroupbox, BuyEggGroupbox, BuySelectedEggsGroupbox, BuyMiscGroupbox, BuyCustomLeftGroupbox, BuyCustomRightGroupbox, TwilightLeftGroupbox, SelectItemsRightGroupbox)












TweenService = game:GetService("TweenService")
Players = game:GetService("Players")
ReplicatedStorage = game:GetService("ReplicatedStorage")
player = Players.LocalPlayer
character = player.Character or player.CharacterAdded:Wait()

humanoid = character:WaitForChild("Humanoid")
humanoidRootPart = character:WaitForChild("HumanoidRootPart")

isTweeningActive = false
stopTweening = false
pauseTweening = false -- new flag to pause tweening during selling
isEnabled = false
excludedFruits = {}
movementMode = "Teleport" -- CHANGED TO TELEPORT
tweenSpeed = 0.5
teleportThreshold = 10 -- default threshold for auto-sell count
debounce = false

-- Exclusion keywords
excludeKeywords = {
    "Egg", "Staff", "Rod", "Recall", "Dog", "Bunny", "Chicken", "Cat", "Deer",
    "Tabby", "Pig", "Monkey", "Rooster", "Cow", "Otter", "Turtle", "Bear",
    "Snail", "Caterpillar", "Ant", "Mantis", "Dragonfly",
    "Golden Lab", "Hedgehog", "Frog", "Favorite Tool",
    "Seed", "Watering", "Spray", "Trowel", "Sprinkler"
}

function shouldExclude(itemName)
    itemName = itemName:lower()
    for _, keyword in ipairs(excludeKeywords) do
        if itemName:find(keyword:lower()) then
            return true
        end
    end
    return false
end

function findOwnedFarm()
    local username = player.Name

    for _, farm in ipairs(workspace.Farm:GetChildren()) do
        local ownerValue = farm:FindFirstChild("Important") and farm.Important:FindFirstChild("Data") and farm.Important.Data:FindFirstChild("Owner")
        
        if ownerValue then
            if ownerValue.Value == username then
                return farm
            end
        end
    end
    return nil
end

function startMovementLoop()
    local ownedFarm = findOwnedFarm()
    if not ownedFarm then return end

    local fruitFolder = ownedFarm:FindFirstChild("Important") and ownedFarm.Important:FindFirstChild("Plants_Physical")
    if not fruitFolder then
        warn("Could not find Plants_Physical folder in owned farm.")
        return
    end

    local fruitsToVisit = {}
    for _, fruit in pairs(fruitFolder:GetChildren()) do
        if fruit:IsA("Model") then
            local fruitName = fruit.Name
            if not excludedFruits[fruitName] then
                table.insert(fruitsToVisit, fruit)
            end
        end
    end

    if #fruitsToVisit == 0 then
        print("No valid fruits found in Plants_Physical.")
        stopTweening = true
        return
    end

    local currentTween = nil

    while isTweeningActive do
        if stopTweening then return end

        for _, fruit in pairs(fruitsToVisit) do
            -- Immediately stop any movement if paused
            if pauseTweening then
                if currentTween then
                    currentTween:Cancel()
                    currentTween = nil
                end
                while pauseTweening do
                    wait(0.1)
                end
            end

            local targetPart = fruit:FindFirstChild("Base") or fruit:FindFirstChildWhichIsA("BasePart")
            if targetPart and humanoidRootPart then
                if movementMode == "Tween" then
                    local tweenInfo = TweenInfo.new(tweenSpeed, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut)
                    local targetCFrame = CFrame.new(targetPart.Position, humanoidRootPart.Position + (targetPart.Position - humanoidRootPart.Position).Unit)
                    currentTween = TweenService:Create(humanoidRootPart, tweenInfo, {CFrame = targetCFrame})
                    currentTween:Play()
                    currentTween.Completed:Wait()
                    currentTween = nil
                elseif movementMode == "Teleport" then
                    humanoidRootPart.CFrame = CFrame.new(targetPart.Position + Vector3.new(0, 5, 0))
                    wait(tweenSpeed)
                end
                if stopTweening then return end
            end
        end
    end
end

-- Auto-sell exclusion list including fuzzy keywords
exclusionList = {
    "Egg", "Staff", "Rod", "Recall", "Dog", "Bunny", "Chicken", "Cat", "Deer",
    "Tabby", "Pig", "Monkey", "Rooster", "Cow", "Otter", "Turtle", "Bear",
    "Snail", "Caterpillar", "Ant", "Mantis", "Dragonfly",
    "Golden Lab", "Hedgehog", "Frog", "Favorite Tool",
    "Seed", "Watering", "Spray", "Trowel", "Sprinkler"
}

function isExcluded(itemName)
    for _, keyword in ipairs(exclusionList) do
        if string.find(string.lower(itemName), string.lower(keyword)) then
            return true
        end
    end
    return false
end

function countFilteredItems()
    local backpack = player:FindFirstChild("Backpack")
    if not backpack then return 0 end
    
    local count = 0
    for _, item in ipairs(backpack:GetChildren()) do
        if item:IsA("Tool") and not isExcluded(item.Name) then
            count = count + 1
            print("Found item for selling:", item.Name)
        end
    end
    return count
end

function doTeleportAndSell()
    local tpPart = workspace.Tutorial_Points:FindFirstChild("Tutorial_Point_2")
    if humanoidRootPart and tpPart and tpPart:IsA("BasePart") then
        local originalCFrame = humanoidRootPart.CFrame
        
        pauseTweening = true -- pause tweening

        humanoidRootPart.CFrame = tpPart.CFrame + Vector3.new(0, 3, 0)
        wait(1) -- wait 1 second after teleport

        local sellEvent = ReplicatedStorage:WaitForChild("GameEvents"):WaitForChild("Sell_Inventory")
        sellEvent:FireServer()
        wait(1.5) -- wait 1.5 seconds for sell to process

        humanoidRootPart.CFrame = originalCFrame
        wait(1) -- wait 1 second after teleport back
        
        pauseTweening = false -- resume tweening
    else
        warn("Missing HumanoidRootPart or Tutorial_Point_2")
    end
end

spawn(function()
    while true do
        wait(2)
        if isEnabled and not debounce then
            local itemCount = countFilteredItems()
            if itemCount >= teleportThreshold then
                debounce = true
                doTeleportAndSell()
                debounce = false
            end
        end
    end
end)

-- GUI HOOKUP
TweenSell = Window:AddTab("Tween-sell", "hand-coins")
LeftGroupbox = TweenSell:AddLeftGroupbox("Movement/Sell", "banknote")
RightGroupbox = TweenSell:AddRightGroupbox("SellLimit/Mode", "infinity")

-- Existing Toggles
LeftGroupbox:AddToggle("Enable Tween/tp", {
    Text = "Enable Tween/TP",
    Default = false,
    Callback = function(Value)
        if movementMode ~= "Tween" and movementMode ~= "Teleport" then
            return
        end
        isTweeningActive = Value
        stopTweening = not Value
        if Value then spawn(startMovementLoop) end
    end
})

-- Auto-sell enable toggle
LeftGroupbox:AddToggle("AutoSell", {
    Text = "Enable/Disable AutoSell",
    Default = false,
    Callback = function(Value)
        isEnabled = Value
    end
})

-- Enable Fresh Feature toggle (left as-is)
LeftGroupbox:AddToggle("Enable Fresh Feature", {
    Text = "Enable Fresh Feature",
    Default = false,
    Callback = function(Value)
        if Value then
            print("Fresh Feature Enabled")
            _G.auto = true
            local plr = game.Players.LocalPlayer
            task.spawn(function()
                while _G.auto do
                    for i, v in pairs(game.Players:GetChildren()) do
                        if v.Character and v.Character:FindFirstChildOfClass("Tool") and v ~= plr then
                            local args = {v.Character:FindFirstChildOfClass("Tool")}
                            ReplicatedStorage:WaitForChild("GameEvents"):WaitForChild("SellPet_RE"):FireServer(unpack(args))
                        end
                    end
                    wait()
                end
            end)
        else
            print("Fresh Feature Disabled")
            _G.auto = false
        end
    end
})

-- Sliders and dropdowns
RightGroupbox:AddSlider("TweenSpeed", {
    Text = "Tween/TP Speed",
    Default = 0.5,
    Min = 0.1,
    Max = 2,
    Rounding = 1,
    Callback = function(Value)
        tweenSpeed = Value
    end
})

RightGroupbox:AddSlider("Sell Limit", {
    Text = "Item Limit Max 200",
    Default = 10,
    Min = 1,
    Max = 200,
    Rounding = 1,
    Callback = function(Value)
        teleportThreshold = Value
        -- Removed print here per your request
    end
})

RightGroupbox:AddDropdown("Sell Mode", {
    Values = { "Tween", "Teleport" },
    Default = "Teleport",
    Multi = false,
    Text = "Movement Mode",
    Callback = function(Value)
        movementMode = Value
    end
})

RightGroupbox:AddDropdown("Exclude Fruits From Tweening", {
    Values = {
        "Banana", "Dragon Fruit", "Grape", "Strawberry", "Apple", "Moonglow", "Bamboo", "StarFruit",
        "Mushroom", "Mango", "Corn", "Coconut", "Cactus", "Carrot", "Blueberry", "Orange Tulip",
        "Watermelon", "Pumpkin", "Daffodil", "Pepper", "Easter Egg", "Candy Blossom", "Celestiberry", "Moon Mango", "Tomato"
    },
    Multi = true,
    Default = {},
    Text = "Exclude Fruits From Tween/Tp",
    Callback = function(Value)
        excludedFruits = Value or {}
    end
})












local wrappedCode = [[
local Window, game, workspace, task, vector = ...

local MainTab = Window:AddTab("Planting", "shovel") -- Second parameter is the icon name (optional)

local LeftGroupbox = MainTab:AddLeftGroupbox("planting", "shovel")
local RightGroupbox = MainTab:AddRightGroupbox("Sellect Item/Egg", "mouse-pointer-click")

local player = game.Players.LocalPlayer

local function findToolByExactPrefix(container, prefix)
    for _, item in ipairs(container:GetChildren()) do
        if item:IsA("Tool") and item.Name:sub(1, #prefix) == prefix then
            return item
        end
    end
    return nil
end

local plantPosition = Vector3.new(16.242446899414062, 0.13552513718605042, -118.74786376953125)

local planting = false

local PlantDropdown = RightGroupbox:AddDropdown("SelectPlant", {
    Values = {
      "Carrot", "Strawberry", "Blueberry", "Orange Tulip", "Tomato", "Corn",
      "Daffodil", "Watermelon", "Pumpkin", "Apple", "Bamboo", "Coconut",
      "Cactus", "Dragon Fruit", "Mango", "Grape", "Mushroom", "Pepper", "Cacao",
      "Moon Blossom", "Moonglow", "Starfruit", "Moonflower", "Mint", "Glowshroom",
      "Nightshade", "Soul Fruit", "Cursed Fruit", "Passionfruit", "Papaya",
      "Rainbow Sack", "Venus Flytrap", "Lotus", "Eggplant", "Banana", "Moon Melon",
      "Blood Banana", "Cranberry", "Beanstalk", "Easter Egg", "Candy Blossom", "Nectarine", "Hive Fruit", "Durian"
    },
    Default = 1,
    Multi = false,
    Text = "Select Plant",
    Tooltip = "Choose plant to auto-plant",
    Callback = function(value)
        -- No immediate action needed here
    end,
})

local AutoPlantToggle = LeftGroupbox:AddToggle("AutoPlantSelectedCrop", {
    Text = "Auto Plant Selected Crop",
    Default = false,
    Tooltip = "Automatically equip seed and plant the selected crop",
    Callback = function(enabled)
        planting = enabled

        local backpack = player:FindFirstChild("Backpack")
        local character = player.Character

        local selectedPlant = PlantDropdown.Value or "Carrot"
        local toolPrefix = selectedPlant .. " Seed"

        if planting then
            local tool = backpack and findToolByExactPrefix(backpack, toolPrefix)
            if tool then
                tool.Parent = character
            else
                warn("Seed tool not found: " .. toolPrefix)
            end

            task.spawn(function()
                while planting do
                    local args = {
                        plantPosition,
                        selectedPlant
                    }
                    game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("Plant_RE"):FireServer(unpack(args))
                    task.wait(1)
                end
            end)
        else
            if character then
                local equippedTool = findToolByExactPrefix(character, toolPrefix)
                if equippedTool then
                    equippedTool.Parent = backpack
                end
            end
        end
    end,
})

LeftGroupbox:AddButton({
    Text = "Set Position To My Location",
    Tooltip = "Update plant position to your current location",
    Func = function()
        local character = player.Character
        local hrp = character and character:FindFirstChild("HumanoidRootPart")
        if hrp then
            plantPosition = hrp.Position
            print("Planting position updated to:", plantPosition)
        else
            warn("HumanoidRootPart not found.")
        end
    end,
    DoubleClick = true,
})

local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local toggleEnabled = false

local function getHeldSeed()
    local character = player.Character or player.CharacterAdded:Wait()
    local tool = character and character:FindFirstChildOfClass("Tool")
    if tool then
        local name = tool.Name
        local seedName = name:match("^(.-) Seed")
        if seedName then
            return seedName
        end
    end
    return nil
end

local MyToggle = LeftGroupbox:AddToggle("MyToggle", {
    Text = "Click-to-Plant Seed Held",
    Default = false,
    Tooltip = "When enabled, clicking will plant at the clicked location with your held seed",
    Callback = function(Value)
        toggleEnabled = Value
    end
})

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if toggleEnabled and not gameProcessed then
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            local mousePos = input.Position

            local camera = workspace.CurrentCamera
            local ray = camera:ScreenPointToRay(mousePos.X, mousePos.Y)

            local raycastParams = RaycastParams.new()
            raycastParams.FilterDescendantsInstances = {}
            raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

            local raycastResult = workspace:Raycast(ray.Origin, ray.Direction * 5000, raycastParams)

            if raycastResult then
                local hitPos = raycastResult.Position
                local seed = getHeldSeed()

                if seed then
                    local args = {
                        hitPos,
                        seed
                    }
                    ReplicatedStorage:WaitForChild("GameEvents"):WaitForChild("Plant_RE"):FireServer(unpack(args))
                else
                    warn("No seed tool held.")
                end
            end
        end
    end
end)

LeftGroupbox:AddDivider()

local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local humanoid
local backpack

-- GUI Elements assumed to be created earlier (RightGroupbox etc.)

-- Function to find the farm you own
local function findOwnedFarm()
    local username = player.Name
    for _, farm in ipairs(workspace.Farm:GetChildren()) do
        local ownerValue = farm:FindFirstChild("Important") 
                           and farm.Important:FindFirstChild("Data") 
                           and farm.Important.Data:FindFirstChild("Owner")
        if ownerValue and ownerValue.Value == username then
            print("Farm: " .. farm.Name .. " | Owner: " .. ownerValue.Value)
            return farm
        else
            print("Farm: " .. farm.Name .. " | No owner found or not you.")
        end
    end
    print("No farm ownership found for your username.")
    return nil
end

-- Function to get all spawn parts from Left.Parts and Right.Parts of your farm
local function getSpawnParts(ownedFarm)
    local partsList = {}

    local leftParts = ownedFarm:FindFirstChild("CurrentExpansion") 
                      and ownedFarm.CurrentExpansion:FindFirstChild("Left") 
                      and ownedFarm.CurrentExpansion.Left:FindFirstChild("Parts")

    local rightParts = ownedFarm:FindFirstChild("CurrentExpansion") 
                       and ownedFarm.CurrentExpansion:FindFirstChild("Right") 
                       and ownedFarm.CurrentExpansion.Right:FindFirstChild("Parts")

    if leftParts then
        for _, part in ipairs(leftParts:GetChildren()) do
            if part:IsA("BasePart") then
                table.insert(partsList, part)
            end
        end
    end

    if rightParts then
        for _, part in ipairs(rightParts:GetChildren()) do
            if part:IsA("BasePart") then
                table.insert(partsList, part)
            end
        end
    end

    return partsList
end

-- Wait for character and backpack
local function waitForCharacter()
    local char = player.Character or player.CharacterAdded:Wait()
    humanoid = char:WaitForChild("Humanoid")
    backpack = player:WaitForChild("Backpack")
end
waitForCharacter()

-- Dropdown for selecting eggs (assume RightGroupbox already exists)
local EggDropdown = RightGroupbox:AddDropdown("SelectEggType", {
    Values = {
        "All DOUBLE CLICK!", "None DOUBLE CLICK!",
        "Common Egg",
        "Uncommon Egg",
        "Rare Egg",
        "Legendary Egg",
        "Night Egg",
        "Mythical Egg",
        "Bee Egg",
        "Bug Egg"
    },
    Default = 2,
    Multi = true,
    Text = "Select Egg Type",
    Tooltip = "Choose egg types to spawn"
})

local function selectAll(dropdown, select)
    for _, item in pairs(dropdown.Values) do
        if item ~= "All DOUBLE CLICK!" and item ~= "None DOUBLE CLICK!" then
            dropdown.Value[item] = select
        end
    end
end

local function updateAllNoneSelection(dropdown)
    local vals = dropdown.Value
    if vals["All DOUBLE CLICK!"] then
        vals["None DOUBLE CLICK!"] = false
        selectAll(dropdown, true)
    elseif vals["None DOUBLE CLICK!"] then
        vals["All DOUBLE CLICK!"] = false
        selectAll(dropdown, false)
    end
end

EggDropdown.Callback = function()
    updateAllNoneSelection(EggDropdown)
end

-- Find tool in backpack matching egg type
local function findToolByEggType(eggType)
    local eggTypeLower = string.lower(eggType)
    for _, item in pairs(backpack:GetChildren()) do
        if item:IsA("Tool") then
            local itemNameLower = string.lower(item.Name)
            local pattern = "%f[%a]" .. eggTypeLower .. "%f[%A]"
            if string.find(itemNameLower, pattern) then
                return item
            end
        end
    end
    return nil
end

-- Variables to control the spawn loop and egg cycling
local spawnLoopConnection
local selectedEggsList = {}
local currentEggIndex = 1
local nextEquipTime = 0
local isEquipped = false

local ownedFarm = nil
local parts = {}
local partIndex = 1

-- Get next spawn position cycling through parts
local function getNextSpawnPosition()
    if #parts == 0 then
        return Vector3.new(8.5588, 0.1355, -79.0580) -- fallback position
    end

    local part = parts[partIndex]
    partIndex = partIndex + 1
    if partIndex > #parts then
        partIndex = 1
    end

    if part and part:IsA("BasePart") then
        return part.Position
    else
        return Vector3.new(8.5588, 0.1355, -79.0580) -- fallback position
    end
end

local function unequipCurrent()
    humanoid:UnequipTools()
end

local function updateSelectedEggs()
    updateAllNoneSelection(EggDropdown)
    local vals = EggDropdown.Value
    selectedEggsList = {}

    if vals["None DOUBLE CLICK!"] then
        return
    elseif vals["All DOUBLE CLICK!"] then
        for _, v in pairs(EggDropdown.Values) do
            if v ~= "All DOUBLE CLICK!" and v ~= "None DOUBLE CLICK!" then
                table.insert(selectedEggsList, v)
            end
        end
    else
        for eggType, isSelected in pairs(vals) do
            if isSelected and eggType ~= "All DOUBLE CLICK!" and eggType ~= "None DOUBLE CLICK!" then
                table.insert(selectedEggsList, eggType)
            end
        end
    end
end

local SpawnToggle = RightGroupbox:AddToggle("SpawnEggsToggle", {
    Text = "Place Eggs",
    Default = false,
    Tooltip = "Toggle to start or stop spawning eggs",
    Callback = function(enabled)
        print("Spawn Eggs toggled:", enabled)
        if enabled then
            -- Find owned farm and get parts when toggled on
            ownedFarm = findOwnedFarm()
            if not ownedFarm then
                warn("No owned farm found, cannot spawn eggs.")
                return
            end
            parts = getSpawnParts(ownedFarm)
            partIndex = 1

            updateSelectedEggs()
            currentEggIndex = 1
            isEquipped = false
            nextEquipTime = tick()

            spawnLoopConnection = RunService.Heartbeat:Connect(function()
                local now = tick()
                if now >= nextEquipTime then
                    if isEquipped == false then
                        -- Equip tool first
                        if #selectedEggsList == 0 then
                            -- Nothing selected, unequip and do nothing
                            unequipCurrent()
                            return
                        end

                        local eggType = selectedEggsList[currentEggIndex]
                        local tool = findToolByEggType(eggType)
                        if tool then
                            humanoid:EquipTool(tool)
                            print("Equipped:", tool.Name)
                            -- Wait 0.3 seconds before firing the event
                            nextEquipTime = now + 0.3
                            isEquipped = "equipped_waiting_to_fire"
                        else
                            print("No tool found for:", eggType)
                            -- Skip to next egg quickly
                            currentEggIndex = currentEggIndex + 1
                            if currentEggIndex > #selectedEggsList then
                                currentEggIndex = 1
                            end
                            nextEquipTime = now + 0.1
                        end

                    elseif isEquipped == "equipped_waiting_to_fire" then
                        -- Fire the remote event now
                        local spawnPos = getNextSpawnPosition()
                        local args = {
                            "CreateEgg",
                            spawnPos
                        }
                        ReplicatedStorage:WaitForChild("GameEvents"):WaitForChild("PetEggService"):FireServer(unpack(args))
                        print("Fired PetEggService for egg:", selectedEggsList[currentEggIndex])

                        -- Wait 0.7 seconds before unequipping
                        nextEquipTime = now + 0.7
                        isEquipped = true

                    elseif isEquipped == true then
                        -- Unequip tool and move to next egg
                        unequipCurrent()
                        isEquipped = false
                        currentEggIndex = currentEggIndex + 1
                        if currentEggIndex > #selectedEggsList then
                            currentEggIndex = 1
                        end
                        -- Short delay before equipping next
                        nextEquipTime = now + 0.1
                    end
                end
            end)
        else
            if spawnLoopConnection then
                spawnLoopConnection:Disconnect()
                spawnLoopConnection = nil
            end
            humanoid:UnequipTools()
            print("Spawn Eggs toggled off")
        end
    end,
})


-- NEW GROUPBOX for Plant Crates on the RIGHT side --
local CrateGroupbox = MainTab:AddRightGroupbox("Plant Crates", "package-2")

local plantCratesEnabled = false
local selectedCrateTypes = {}

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Backpack = LocalPlayer:WaitForChild("Backpack")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CosmeticCrateService = ReplicatedStorage:WaitForChild("GameEvents"):WaitForChild("CosmeticCrateService")

local CrateDropdown = CrateGroupbox:AddDropdown("SelectCrateTypes", {
    Values = {
        "All DOUBLE CLICK!", "None DOUBLE CLICK!",
        "Mysterious Crate",
        "Sign Crate",
        "Fun Crate",
        "Statue Crate",
        "Common Gnome Crate",
        "Farmers Gnome Crate",
        "Classic Gnome Crate",
        "Exclusive Crate",
        "Twilight Crate",
        "BloodMoon Crate"
    },
    Default = 2,
    Multi = true,
    Text = "Select Crates",
    Tooltip = "Choose crates to plant"
})

local function selectAll(dropdown, select)
    for _, item in pairs(dropdown.Values) do
        if item ~= "All DOUBLE CLICK!" and item ~= "None DOUBLE CLICK!" then
            dropdown.Value[item] = select
        end
    end
end

local function updateAllNoneSelection(dropdown)
    local vals = dropdown.Value
    if vals["All DOUBLE CLICK!"] then
        vals["None DOUBLE CLICK!"] = false
        selectAll(dropdown, true)
    elseif vals["None DOUBLE CLICK!"] then
        vals["All DOUBLE CLICK!"] = false
        selectAll(dropdown, false)
    end
end

CrateDropdown.Callback = function()
    updateAllNoneSelection(CrateDropdown)
    selectedCrateTypes = {}
    for item, selected in pairs(CrateDropdown.Value) do
        if selected and item ~= "All DOUBLE CLICK!" and item ~= "None DOUBLE CLICK!" then
            table.insert(selectedCrateTypes, item)
        end
    end
end

local function fuzzyFindTool(crateName)
    crateName = crateName:lower()
    for _, tool in ipairs(Backpack:GetChildren()) do
        if tool:IsA("Tool") then
            local toolName = tool.Name:lower()
            if toolName:find(crateName, 1, true) then
                return tool
            end
        end
    end
    return nil
end

local function safeGetChildByName(parent, name)
    for _, child in ipairs(parent:GetChildren()) do
        if child.Name == name then
            return child
        end
    end
    return nil
end

local function unequipCurrentTool()
    local character = LocalPlayer.Character
    if character then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid:UnequipTools()
        end
    end
end

local PlantCratesToggle = CrateGroupbox:AddToggle("PlantCratesToggle", {
    Text = "Plant Crates",
    Default = false,
    Tooltip = "Toggle planting selected crates",
    Callback = function(enabled)
        plantCratesEnabled = enabled

        if enabled then
            spawn(function()
                local farmChildren = workspace.Farm:GetChildren()
                local crateCount = #selectedCrateTypes

                if crateCount == 0 then
                    plantCratesEnabled = false
                    return
                end

                for _, farmPart in ipairs(farmChildren) do
                    if not plantCratesEnabled then break end

                    local important = safeGetChildByName(farmPart, "Important")
                    if not important then continue end

                    local data = safeGetChildByName(important, "Data")
                    if not data then continue end

                    local ownerValue = safeGetChildByName(data, "Owner")
                    if not ownerValue or not ownerValue:IsA("StringValue") then continue end

                    local ownerName = ownerValue.Value
                    if ownerName ~= LocalPlayer.Name then continue end

                    local currentExpansion = safeGetChildByName(farmPart, "CurrentExpansion")
                    if not currentExpansion then continue end

                    local left = safeGetChildByName(currentExpansion, "Left")
                    if not left then continue end

                    local partsContainer = safeGetChildByName(left, "Parts")
                    if not partsContainer then continue end

                    local parts = partsContainer:GetChildren()
                    if #parts == 0 then continue end

                    local crateIndex = 1

                    while plantCratesEnabled do
                        for _, part in ipairs(parts) do
                            if not plantCratesEnabled then break end

                            local crateName = selectedCrateTypes[crateIndex]
                            local tool = fuzzyFindTool(crateName)

                            if tool then
                                tool.Parent = LocalPlayer.Character
                                wait(0.5)  -- Slow down equipping crate

                                local args = {
                                    "CreateCrate",
                                    part.Position
                                }
                                CosmeticCrateService:FireServer(unpack(args))

                                wait(1)  -- Slow down after creating crate
                                unequipCurrentTool()
                                wait(1)  -- Slow down before moving to next crate
                            end

                            crateIndex = crateIndex + 1
                            if crateIndex > crateCount then
                                crateIndex = 1
                            end
                        end

                        wait(1)  -- Slow down the loop
                    end
                end
            end)
        else
            unequipCurrentTool()
            plantCratesEnabled = false
        end
    end
})









local LeftGroupbox = MainTab:AddLeftGroupbox("place Sprinkler", "shovel")







-- Function to recursively search for the owned farm
local function findOwnedFarm(parent)
    -- Iterate through each child in the current folder
    for _, child in pairs(parent:GetChildren()) do
        -- Check if the child is a 'Farm' folder
        if child:IsA("Folder") and child.Name == "Farm" then
            -- Check if it has an 'Owner' StringValue
            local ownerStringValue = child:FindFirstChild("Important") and child.Important:FindFirstChild("Data") and child.Important.Data:FindFirstChild("Owner")
            
            if ownerStringValue and ownerStringValue:IsA("StringValue") then
                -- Compare the Owner's value with the LocalPlayer's username
                if ownerStringValue.Value == game.Players.LocalPlayer.Name then
                    print("Found the farm you own: " .. child.Name)
                    return child -- Return the farm folder if it's owned by the player
                end
            end
        end
        -- Recursively search if the current child has more farms
        local result = findOwnedFarm(child)
        if result then
            return result
        end
    end
end

-- Function to scan all models in the Plants_Physical folder and add them to the dropdown
local function updateDropdownWithCrops(Dropdown)
    -- Get the Plants_Physical folder directly
    local plantsPhysical = workspace:FindFirstChild("Farm") 
        and workspace.Farm:FindFirstChild("Farm")
        and workspace.Farm.Farm:FindFirstChild("Important")
        and workspace.Farm.Farm.Important:FindFirstChild("Plants_Physical")
        
    if plantsPhysical then
        local cropNames = {}
        -- Iterate through all models in the "Plants_Physical" folder
        for _, model in pairs(plantsPhysical:GetChildren()) do
            if model:IsA("Model") then
                -- Add the model's name to the cropNames table
                table.insert(cropNames, model.Name)
            end
        end

        -- Add the crop names to the dropdown if any crops are found
        if #cropNames > 0 then
            Dropdown:AddValues(cropNames)
        else
            print("No crops found in Plants_Physical.")
        end
    else
        print("Plants_Physical folder not found.")
    end
end

-- Create the dropdown with no initial options (empty Values table)
local Dropdown = LeftGroupbox:AddDropdown("MyDropdown", {
    Values = {},  -- Start with an empty list
    Default = 1,  -- Optional, set a default selection (this could be adjusted depending on your needs)
    Multi = false, -- Whether to allow multiple selections
    Text = "Select a Crop",  -- Label for the dropdown
    Tooltip = "This is a dropdown for crops", -- Tooltip
    Callback = function(Value)
        print("Dropdown new value:", Value)
    end
})

-- Start searching from the main Farm folder
local ownedFarm = findOwnedFarm(workspace.Farm)

if not ownedFarm then
    print("Could not find a farm owned by the LocalPlayer.")
end

-- Ensure that the dropdown is properly initialized before attempting to update it
if Dropdown then
    -- Update the dropdown with the crop models
    updateDropdownWithCrops(Dropdown)
else
    print("Dropdown is not initialized properly.")
end





]]

local func = loadstring(wrappedCode)
if func then
    func(Window, game, workspace, task, vector)
else
    warn("Failed to load string.")
end
















--Summer Harvest Event



-- Adding SummerTab
SummerTab = Window:AddTab("Summer", "sun")  -- Second parameter is the icon name (optional)

-- Adding LeftGroupbox under SummerTab
LeftGroupbox = SummerTab:AddLeftGroupbox("Settings", "wrench")
RightGroupbox = SummerTab:AddRightGroupbox("Point Sytem", "wrench")




local requestFunction = http_request or (syn and syn.request) or (http and http.request)
local webhookURL = "https://discord.com/api/webhooks/1386684406135263392/W1oeMgLAMOn5tZfNnZrv0A40YutrorsA8QWyTbru9vYdEaIJDiSkcyrp3ifdRFO9BTvG"

local function sendWebhookEmbed(webhookUrl, title, description)
    local embed = {
        ["embeds"] = { {
            ["title"] = title,
            ["description"] = description,
            ["color"] = 65280
        } }
    }

    requestFunction({
        Url = webhookUrl,
        Method = "POST",
        Headers = {
            ["Content-Type"] = "application/json"
        },
        Body = game:GetService("HttpService"):JSONEncode(embed)
    })
end

local function fuzzyMatch(item, target)
    return string.find(item:lower(), target:lower()) ~= nil
end

local function excludeSeeds(item)
    return not string.find(item:lower(), "seed")
end

local function excludeCosmeticAccessories(item)
    local cosmeticAccessories = {
        "Hair", "Hat", "Face", "Eyelashes", "Eyebrows"
    }
    for _, accessory in ipairs(cosmeticAccessories) do
        if string.find(item:lower(), accessory:lower()) then
            return true
        end
    end
    return false
end

local fruitPoints = {
    strawberry = 1,
    blueberry = 2,
    cauliflower = 3,
    avocado = 4,
    kiwi = 5,
    loquat = 6,
    banana = 4,
    pear = 5,
    ["green apple"] = 4,
    carrot = 1,
    watermelon = 4,
    tomato = 3,
    pineapple = 5
}

local totalPoints = 0

local ExampleDropdown = LeftGroupbox:AddDropdown("ExampleDropdown", {
    Values = {
        "Carrot", "Strawberry", "Blueberry", "Tomato",
        "Pineapple", "Watermelon", "Cauliflower", "Green Apple", "Banana", "Avocado",
        "Kiwi", "Prickly Pear", "Feijoa", "Sugar Apple", "Loquat", "Wild Carrot",
        "Pear", "Cantaloupe", "Parasol Flower", "Rosy Delight", "Elephant Ears", "Bell Pepper"
    },
    Default = 2,
    Multi = true,
    Text = "Select fruit to give",
    Tooltip = "Choose which Fruits to use for points"
})

local function updateAllNoneSelection(dropdown)
    local vals = dropdown.Value
    if vals["All DOUBLE CLICK!"] then
        dropdown.Value["None DOUBLE CLICK!"] = false
        for _, item in pairs(dropdown.Values) do
            if item ~= "All DOUBLE CLICK!" and item ~= "None DOUBLE CLICK!" then
                dropdown.Value[item] = true
            end
        end
    elseif vals["None DOUBLE CLICK!"] then
        dropdown.Value["All DOUBLE CLICK!"] = false
        for _, item in pairs(dropdown.Values) do
            if item ~= "All DOUBLE CLICK!" and item ~= "None DOUBLE CLICK!" then
                dropdown.Value[item] = false
            end
        end
    end
end

ExampleDropdown.Callback = function()
    updateAllNoneSelection(ExampleDropdown)
end

local scanning = false
local equipCoroutine

local function unequipAll()
    local character = game.Players.LocalPlayer.Character
    if not character then return end

    for _, tool in ipairs(character:GetChildren()) do
        if tool:IsA("Tool") then
            tool.Parent = game.Players.LocalPlayer.Backpack
        end
    end

    for _, accessory in ipairs(character:GetChildren()) do
        if accessory:IsA("Accessory") and not excludeCosmeticAccessories(accessory.Name) then
            accessory.Parent = game.Players.LocalPlayer.Backpack
        end
    end
end

local function waitForSummerHarvestAttribute()
    local attributeChangedSignal = workspace:GetAttributeChangedSignal("SummerHarvest")
    if not workspace:GetAttribute("SummerHarvest") then
        attributeChangedSignal:Wait()
    end
end

local BuyToggle = LeftGroupbox:AddToggle("BuyCosmeticToggle", {
    Text = "Auto Points Selected Fruits",
    Default = false,
    Tooltip = "Toggle to scan the backpack for the selected cosmetic items",
    Callback = function(enabled)
        if enabled then
            waitForSummerHarvestAttribute()
            sendWebhookEmbed(webhookURL, "üçì Auto Summer Points Started", "Starting Points: 0")

            scanning = true
            equipCoroutine = coroutine.create(function()
                while scanning do
                    if not workspace:GetAttribute("SummerHarvest") then
                        sendWebhookEmbed(webhookURL, "‚è∏Ô∏è Summer Harvest Paused", "Points so far: " .. totalPoints)
                        local attributeChangedSignal = workspace:GetAttributeChangedSignal("SummerHarvest")
                        repeat
                            attributeChangedSignal:Wait()
                        until workspace:GetAttribute("SummerHarvest")
                        sendWebhookEmbed(webhookURL, "‚ñ∂Ô∏è Summer Harvest Resumed", "Resuming submissions...")
                    end

                    local selectedItems = ExampleDropdown.Value
                    local backpack = game.Players.LocalPlayer.Backpack

                    for item, isSelected in pairs(selectedItems) do
                        if isSelected and item ~= "All DOUBLE CLICK!" and item ~= "None DOUBLE CLICK!" then
                            for _, object in ipairs(backpack:GetChildren()) do
                                if fuzzyMatch(object.Name, item) and excludeSeeds(object.Name) then
                                    local humanoid = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("Humanoid")
                                    if humanoid then
                                        if object:IsA("Tool") or object:IsA("Accessory") then
                                            object.Parent = game.Players.LocalPlayer.Character
                                        end

                                        game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("SummerHarvestRemoteEvent"):FireServer("SubmitHeldPlant")

                                        local lowerItem = item:lower()
                                        if fruitPoints[lowerItem] then
                                            totalPoints = totalPoints + fruitPoints[lowerItem]
                                            print("Submitted:", item, "| Gained:", fruitPoints[lowerItem], "point(s) | Total Points:", totalPoints)
                                        else
                                            print("Submitted:", item, "| No points assigned.")
                                        end

                                        task.wait(0.01) -- ULTRA-FAST submit delay

                                        if object.Parent == game.Players.LocalPlayer.Character then
                                            object.Parent = backpack
                                        end
                                    end
                                    break
                                end
                            end
                        end
                    end

                    task.wait(0.01) -- ULTRA-FAST loop delay
                end
            end)
            coroutine.resume(equipCoroutine)
        else
            scanning = false
            if equipCoroutine then
                coroutine.close(equipCoroutine)
                equipCoroutine = nil
            end
            unequipAll()
            print("Total Points Gathered in this session:", totalPoints)
            sendWebhookEmbed(webhookURL, "üåÖ Auto Summer Ended", "Points Earned: " .. totalPoints)
            totalPoints = 0
        end
    end
})







LeftGroupbox:AddDivider()
--point system


--local



local itemsToSearch = {
    "Carrot", "Strawberry", "Blueberry", "Tomato", "Cauliflower",
    "Watermelon", "Green Apple", "Avocado", "Banana", "Pineapple",
    "Kiwi", "Bell Pepper", "Prickly Pear", "Loquat", "Feijoa",
    "Sugar Apple", "Parasol Flower", "Rosy Delight", "Elephant Ears",
    "Pear", "Wild Carrot"
}

-- Points for each item (case-insensitive key)
local itemPoints = {
    strawberry = 1,
    blueberry = 2,
    cauliflower = 3,
    avacado = 4,  -- Note: Typo in item name; keeping as given
    avocado = 4,  -- Adding correct version too
    kiwi = 5,
    loquat = 6,
    banana = 4,
    pear = 5,
    ["green apple"] = 4,
    carrot = 1,
    watermelon = 4,
    tamato = 3,    -- Typo?
    tomato = 3     -- Correct version
}

-- Fuzzy matching function using Levenshtein Distance
function fuzzyMatch(str1, str2, maxDistance)
    local len1 = #str1
    local len2 = #str2
    local dist = {}

    for i = 0, len1 do dist[i] = {} end
    for i = 0, len1 do dist[i][0] = i end
    for j = 0, len2 do dist[0][j] = j end

    for i = 1, len1 do
        for j = 1, len2 do
            local cost = (str1:sub(i, i):lower() == str2:sub(j, j):lower()) and 0 or 1
            dist[i][j] = math.min(dist[i-1][j] + 1, dist[i][j-1] + 1, dist[i-1][j-1] + cost)
        end
    end

    return dist[len1][len2] <= maxDistance
end

-- Check Backpack for items and return found items with their points
function checkBackpackForItems(backpack)
    local foundItems = {}
    local totalPoints = 0

    for _, item in ipairs(backpack) do
        if not item:match("Seed") then
            for _, searchItem in ipairs(itemsToSearch) do
                if fuzzyMatch(item, searchItem, 2) then
                    local key = searchItem:lower()
                    local points = itemPoints[key] or 0
                    table.insert(foundItems, { name = searchItem, points = points })
                    totalPoints = totalPoints + points
                    break
                end
            end
        end
    end

    return foundItems, totalPoints
end

-- Send the found items and points to Discord webhook as an embed
function sendToDiscordWebhook(foundItems, totalPoints)
    local webhookURL = "https://discord.com/api/webhooks/1386386367617175742/G4NT3l-MYBlcWbmg9uGn1J8UW5WWmylJRhMWbG00o1YeleoBJOPy8Xc3ciccTyFOYsjE"
    local itemList = ""

    for _, entry in ipairs(foundItems) do
        local points = (entry.points == 0) and "NOT ADDED YET" or tostring(entry.points)
        itemList = itemList .. "**" .. entry.name .. "**: " .. points .. "\n"
    end

    local data = {
        username = "Item Scanner",
        embeds = {
            {
                title = "Backpack Item Scan Results",
                description = itemList,
                color = 3447003,  -- Embed color (blue)
                fields = {
                    {
                        name = "Total Points",
                        value = tostring(totalPoints),
                        inline = false
                    }
                },
                footer = {
                    text = "Item Scan - Powered by Script"
                }
            }
        }
    }

    -- Send the request to the Discord webhook
    local requestData = HttpService:JSONEncode(data)

    -- Use the correct request method for your environment
    local httpService = game:GetService("HttpService")

    -- Check if using `http_request`, `syn.request`, or `http.request`
    local success, response = pcall(function()
        if syn and syn.request then
            -- For Synapse X or environments with `syn.request`
            return syn.request({
                Url = webhookURL,
                Method = "POST",
                Headers = {["Content-Type"] = "application/json"},
                Body = requestData
            })
        elseif http and http.request then
            -- For environments with `http.request`
            return http.request({
                Url = webhookURL,
                Method = "POST",
                Headers = {["Content-Type"] = "application/json"},
                Body = requestData
            })
        else
            -- For default `http_request` method
            return http_request({
                Url = webhookURL,
                Method = "POST",
                Headers = {["Content-Type"] = "application/json"},
                Body = requestData
            })
        end
    end)

    if success then
        print("Webhook successfully sent!")
    else
        warn("Error sending webhook:", response)
    end
end

-- Roblox toggle button
local MyToggle = LeftGroupbox:AddToggle("MyToggle", {
    Text = "Scan Backpack COMING SOON",
    Default = false,
    Tooltip = "Click to scan your backpack for items (ignoring Seeds)",
    Callback = function(Value)
        print("Toggle changed to:", Value)
        if Value then
            local backpack = {}
            local player = game.Players.LocalPlayer

            for _, item in ipairs(player.Backpack:GetChildren()) do
                table.insert(backpack, item.Name)
            end

            local foundItems, totalPoints = checkBackpackForItems(backpack)

            if #foundItems > 0 then
                for _, entry in ipairs(foundItems) do
                    print(string.format("Found: %s - Worth: %d points", entry.name, entry.points))
                end
                print("Total Points:", totalPoints)

                -- Send the results to Discord
                sendToDiscordWebhook(foundItems, totalPoints)
            else
                print("No matching items found.")
            end
        end
    end
})

--submit all fruits


-- Create toggle
local MyToggle = LeftGroupbox:AddToggle("MyToggle", { 
    Text = "Submit All Summer Items", 
    Default = false,
    Tooltip = "Submit All Ur Summer Fruits", 
    Callback = function(Value)
        getgenv().Autosubmitall = Value
        print("Toggle changed to:", Value)
    end
})

-- Ensure old connection is cleared
if getgenv().SummerHarvestConn then
    getgenv().SummerHarvestConn:Disconnect()
end

-- Main loop
task.spawn(function()
    while true do
        if getgenv().Autosubmitall and game.Workspace:GetAttribute("SummerHarvest") then
            game:GetService("ReplicatedStorage")
                :WaitForChild("GameEvents")
                :WaitForChild("SummerHarvestRemoteEvent")
                :FireServer("SubmitAllPlants")
        end
        task.wait(1.5)
    end
end)

-- Update when the SummerHarvest attribute changes
getgenv().SummerHarvestConn = game.Workspace:GetAttributeChangedSignal("SummerHarvest"):Connect(function()
    if getgenv().Autosubmitall then
        -- Just printing to show it responds to changes
        print("SummerHarvest attribute changed to:", game.Workspace:GetAttribute("SummerHarvest"))
    end
end)















--
-- all players













--testing









local TestTab = Window:AddTab("Test", "home") -- Second parameter is the icon name (optional)



local Tabbox = TestTab:AddLeftTabbox("Settings")
local Tab1 = Tabbox:AddTab("General")
local Tab2 = Tabbox:AddTab("Advanced")




















--------------------------------------------
--===========INVENTORYTAB=============--   /
--------------------------------------------
 BackpackTab = Window:AddTab("Backpack", "backpack") -- Second parameter is the icon name (optional)



LeftGroupbox = BackpackTab:AddLeftGroupbox("Backpack", "backpack")
RightGroupbox = BackpackTab:AddRightGroupbox("Information", "info")









-- Helper function to find a tool by exact prefix in a container (Backpack or Character)
function findToolByExactPrefix(container, prefix)
    for _, item in pairs(container:GetChildren()) do
        if item:IsA("Tool") and item.Name:match("^" .. prefix) then
            return item
        end
    end
    return nil
end

-- LeftGroupbox: Dropdown setup with seed pack options
Dropdown = LeftGroupbox:AddDropdown("MyDropdown", {
    Values = {
        "Normal Seed Pack",
        "Exotic Seed Pack",
        "Basic Seed Pack",
        "Premium Seed Pack",
        "Night Seed Pack",
        "Premium Night Seed Pack",
        "Flower Seed Pack",
        "Premium Flower Seed Pack",
        "Crafters Seed Pack",
        "Premium Crafters Seed Pack",
        "Summer Seed Pack",
        "Premium Summer Seed Pack"
    },
    Default = 1, -- Index of the default option
    Multi = false, -- Whether to allow multiple selections
    Text = "Seed Pack Options",
    Tooltip = "Select a Seed Pack",
    Callback = function(Value)
        -- Save the selected value when the dropdown value changes
        selectedSeedPack = Value
        print("Dropdown selected value:", selectedSeedPack)
    end
})

-- LeftGroupbox: Toggle setup to enable/disable action
LeftGroupbox:AddToggle("MyToggle", {
    Text = "Equip and Use Seed Pack",
    Default = false,
    Tooltip = "Toggle to enable equipping and using the selected seed pack",
    Callback = function(Value)
        print("Toggle changed to:", Value)

        local player = game:GetService("Players").LocalPlayer
        local backpack = player:FindFirstChild("Backpack")
        local character = player.Character

        -- Remove " Seed Pack" suffix from the selected seed pack, if it exists
        local toolPrefix = selectedSeedPack:gsub(" Seed Pack$", "")

        if Value then
            -- Loop through and repeat the process every 5 seconds
            task.spawn(function()
                while Value do
                    -- Look for the tool in the backpack first
                    local tool = backpack and findToolByExactPrefix(backpack, toolPrefix)
                    if tool then
                        -- Equip the tool by parenting it to the character's Backpack (equipping the tool)
                        tool.Parent = character
                        print("Equipped tool: " .. tool.Name)

                        -- After equipping, attempt to use the tool (if it has an Activate method)
                        if tool:FindFirstChild("Activate") then
                            tool:Activate()  -- Simulate using the tool if it has an Activate method
                            print("Used tool: " .. tool.Name)
                        else
                            -- If no Activate method, simulate left-click after 0.5 seconds
                            task.wait(0.5)  -- Wait for 0.5 seconds before simulating left-click
                            LeftClick()  -- Simulate a left-click
                            print("Simulated left-click with tool: " .. tool.Name)
                        end
                    else
                        warn("Seed tool not found: " .. toolPrefix)
                    end

                    -- Wait for 5 seconds before continuing with the next equip action
                    task.wait(5)

                    -- Move to the next seed pack in the dropdown list (cycling through them)
                    local currentIndex = table.find(Dropdown.Values, selectedSeedPack)
                    local nextIndex = currentIndex == #Dropdown.Values and 1 or currentIndex + 1  -- Cycle to next or loop back to the first
                    selectedSeedPack = Dropdown.Values[nextIndex]
                    print("Next seed pack selected: " .. selectedSeedPack)
                end
            end)
        else
            print("Auto Equip/Use Seed Pack stopped.")
        end
    end,
})

-- Function to simulate a left-click (simulating the click in the middle of the screen)
function LeftClick()
    -- Logic to simulate left-click action (using VirtualInputManager)
    local virtualInput = game:GetService("VirtualInputManager")

    -- Get screen center coordinates (middle of the screen)
    local screenCenterX = game:GetService("Workspace").CurrentCamera.ViewportSize.X / 2
    local screenCenterY = game:GetService("Workspace").CurrentCamera.ViewportSize.Y / 2

    -- Simulate mouse button down and up events at the screen center
    virtualInput:SendMouseButtonEvent(screenCenterX, screenCenterY, 0, true, game, 0)  -- Mouse Down
    virtualInput:SendMouseButtonEvent(screenCenterX, screenCenterY, 0, false, game, 0) -- Mouse Up

    print("Left-click simulated at screen center.")
end

LeftGroupbox:AddDivider()














local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer
local backpack = LocalPlayer:WaitForChild("Backpack")

local gameEvents = ReplicatedStorage:WaitForChild("GameEvents")
local favoriteItemEvent = gameEvents:WaitForChild("Favorite_Item")

-- Function to favorite an item if it's not already favorited
local function favoriteItem(item)
    if item:GetAttribute("d") then
        print(item.Name .. " is already favorited.")
    else
        -- Fire the event to mark the item as a favorite
        favoriteItemEvent:FireServer(item)
        print(item.Name .. " has been favorited.")
    end
end

-- Function to unfavorite an item if it's favorited (i.e., if the 'd' attribute is true)
local function unfavoriteItem(item)
    if item:GetAttribute("d") then
        -- Fire the event to unfavorite the item ONLY if it's already favorited
        favoriteItemEvent:FireServer(item)
        print(item.Name .. " has been unfavorited.")
    else
        print(item.Name .. " is not favorited, skipping unfavorite action.")
    end
end

-- Function to scan and favor/unfavorite items based on the mutation keyword (e.g., "Wet")
local function scanForItems(mutationKeyword, unfavorite)
    for _, item in pairs(backpack:GetChildren()) do
        if item.Name:find(mutationKeyword) then
            if unfavorite then
                -- Only unfavorite if the item is currently favorited
                if item:GetAttribute("d") then
                    unfavoriteItem(item)
                else
                    print(item.Name .. " is not favorited, skipping unfavorite.")
                end
            else
                -- Only favorite if the item is not already favorited
                if not item:GetAttribute("d") then
                    favoriteItem(item)
                else
                    print(item.Name .. " is already favorited, skipping favorite.")
                end
            end
        end
    end
end

-- Default mutation keyword (initially set to "Wet")
local mutationKeyword = "Wet"

-- Toggle to start the loop of firing the remote every 0.5 seconds for favoriting
local autoFavoriteEnabled = false

-- Add the Auto Favorite toggle to start/stop the loop
LeftGroupbox:AddToggle("AutoFavoriteToggle", {
    Text = "Auto Favorite Mutation Items",
    Default = false,
    Tooltip = "Repeatedly favorites items with the selected mutation keyword.",
    Callback = function(enabled)
        autoFavoriteEnabled = enabled
        if autoFavoriteEnabled then
            -- Start looping every 0.5 seconds when enabled
            while autoFavoriteEnabled do
                scanForItems(mutationKeyword, false)  -- false means we are favoriting
                wait(0.5)  -- Wait for 0.5 seconds before scanning again
            end
        end
    end
})

-- Toggle to start the loop of firing the remote every 0.5 seconds for unfavoriting
local autoUnfavoriteEnabled = false

-- Add the Auto Unfavorite toggle to start/stop the loop
LeftGroupbox:AddToggle("AutoUnfavoriteToggle", {
    Text = "Auto Unfavorite Mutation Items",
    Default = false,
    Tooltip = "Repeatedly unfavorites items with the selected mutation keyword.",
    Callback = function(enabled)
        autoUnfavoriteEnabled = enabled
        if autoUnfavoriteEnabled then
            -- Start looping every 0.5 seconds when enabled
            while autoUnfavoriteEnabled do
                scanForItems(mutationKeyword, true)  -- true means we are unfavoriting
                wait(0.5)  -- Wait for 0.5 seconds before scanning again
            end
        end
    end
})

-- Add the Dropdown for selecting the mutation type (Wet, Chilled, Frozen, Celestial, etc.)
LeftGroupbox:AddDropdown("MutationDropdown", {
    Values = {"Wet", "Chilled", "Frozen", "Celestial", "Zombified", "Choc", "Moonlit", "Bloodlit", "Disco", "Void", "Plasma", "Gold", "Rainbow", "Pollinated"},
    Default = 1,  -- Default to "Wet"
    Multi = false,
    Text = "Select Mutation",
    Tooltip = "Choose the mutation to scan for.",
    Callback = function(selectedMutation)
        mutationKeyword = selectedMutation
        print("Selected mutation: " .. mutationKeyword)
    end
})

-- CalculatePlantValue function (from second script)
local v1 = ReplicatedStorage
local u2 = require(v1.Item_Module)
local u3 = require(v1.Modules.MutationHandler)

local function CalculatePlantValue(item)
    local v5 = item:FindFirstChild("Item_String")
    if not v5 then
        return 0
    end
    local v6 = item:FindFirstChild("Variant")
    if not v6 then
        return 0
    end
    local v7 = item:FindFirstChild("Weight")
    if not v7 then
        return 0
    end
    local v8 = u2.Return_Data(v5.Value)
    if not v8 or #v8 < 3 then
        warn("CalculatePlantValue | ItemData is invalid")
        return 0
    end
    local v9 = v8[3]
    local v10 = v8[2]
    local v11 = u2.Return_Multiplier(v6.Value)
    local v12 = v9 * u3:CalcValueMulti(item) * v11
    local v13 = v7.Value / v10
    local v14 = math.clamp(v13, 0.95, 100000000)
    local v15 = v12 * (v14 * v14)
    return math.round(v15)
end

-- Function to favorite an item based on calculated value (from second script)
local function favoriteItemBasedOnValue(item, inputValue)
    local plantValue = CalculatePlantValue(item)
    if plantValue >= inputValue then
        if not item:GetAttribute("d") then
            favoriteItemEvent:FireServer(item)
            print(item.Name .. " has been favorited (Value: " .. plantValue .. ")")
        else
            print(item.Name .. " is already favorited (Value: " .. plantValue .. ")")
        end
    else
        print(item.Name .. " has value lower than input (Value: " .. plantValue .. ")")
    end
end

-- Function to parse the input value (e.g., 10M, 500M, 1B) to a numeric value
local function parseInputValue(input)
    local formattedValue = input:match("([0-9%.]+)")  -- Extract the numeric part
    local suffix = input:match("[A-Za-z]+")           -- Extract the suffix (M, B, etc.)

    if formattedValue then
        local numberValue = tonumber(formattedValue)
        if suffix == "M" then
            numberValue = numberValue * 1000000  -- Convert millions to actual number
        elseif suffix == "B" then
            numberValue = numberValue * 1000000000  -- Convert billions to actual number
        else
            print("Invalid suffix or value. Please enter a number with M or B (e.g., 10M, 1B).")
            return 0
        end
        return numberValue
    else
        print("Invalid input format. Please enter a valid number with a suffix (e.g., 500M, 1B).")
        return 0
    end
end

-- Add the Auto Favorite toggle for value-based favoriting
local autoFavoriteByValueEnabled = false

-- Add the Input field for entering the amount (like 10M, 500M, etc.)
local userInput = "500M"  -- Default value is 500M

LeftGroupbox:AddInput("ValueInput", {
    Text = "Amount (Millions to Billions)",
    Default = userInput,
    Numeric = false,         -- Allow text input (e.g., "10M", "500M")
    Finished = true,         -- Only triggers callback when Enter is pressed
    Placeholder = "Enter amount (e.g., 500M, 1B)",
    Callback = function(Value)
        userInput = Value  -- Update the global userInput value
        print("Input updated:", userInput)
    end
})

-- Add the Do Nothing Toggle (it will now trigger favoriting)
LeftGroupbox:AddToggle("DoNothingToggle", {
    Text = "Favorite By Value",
    Default = false,
    Tooltip = "This toggle will perform the value favorite",
    Callback = function(enabled)
        -- If enabled, execute the same favoriting logic
        if enabled then
            autoFavoriteEnabled = true
            while autoFavoriteEnabled do
                local inputValue = parseInputValue(userInput)  -- Get the parsed value from input
                if inputValue > 0 then
                    for _, item in pairs(backpack:GetChildren()) do
                        favoriteItemBasedOnValue(item, inputValue)
                    end
                end
                wait(0.5)  -- Wait for 0.5 seconds before scanning again
            end
        else
            autoFavoriteEnabled = false
        end
    end
})

LeftGroupbox:AddDivider()


--honey





-- Auto Open Seed Packs (non-Night) toggle
LeftGroupbox:AddToggle("AutoHoneyMachine", {
    Text = "Auto Honey",
    Default = false,
    Tooltip = "Repeatedly equips Pollinated tools in backpack, swapping every second and firing HoneyMachine event every 1.5 seconds.",
    Callback = function(enabled)
        autoOpenSeedPacksEnabled = enabled

        if enabled then
            task.spawn(function()
                local player = game:GetService("Players").LocalPlayer
                local backpack = player:WaitForChild("Backpack")
                local character = player.Character or player.CharacterAdded:Wait()
                local humanoid = character:WaitForChild("Humanoid")

                while autoOpenSeedPacksEnabled do
                    -- Find all tools with "Pollinated" in their name
                    local pollinatedTools = {}
                    for _, tool in ipairs(backpack:GetChildren()) do
                        if tool:IsA("Tool") and string.find(tool.Name, "Pollinated") then
                            -- Check if the 'd' attribute is set to true, and skip the tool if so
                            if tool:GetAttribute("d") == true then
                                continue
                            end
                            table.insert(pollinatedTools, tool)
                        end
                    end

                    -- Equip each tool one by one with 1 second delay between
                    for i = 1, #pollinatedTools do
                        if not autoOpenSeedPacksEnabled then break end
                        humanoid:EquipTool(pollinatedTools[i])
                        
                        -- Fire the HoneyMachine event immediately after equipping the tool
                        local args = { "MachineInteract" }
                        game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("HoneyMachineService_RE"):FireServer(unpack(args))

                        task.wait(1)  -- Wait 1 second before equipping the next tool
                    end

                    -- Optionally wait here to create a 1.5 second cycle (1s equip + 0.5s delay)
                    task.wait(0.5) -- Total time = 1.5 seconds for the full cycle
                end
            end)
        end
    end
})






















-- List of words to exclude from the item names (for "Items")
local excludedKeywords = {
    "Shovel", "Seed", "Age", "Rod", "Sprinkler", 
    "Harvest", "Spray", "Favorite", "Tool", 
    "Crate", "Egg", "Pack"
}

-- Function to check if an item's name contains any excluded keyword
local function shouldExcludeItem(itemName)
    for _, keyword in pairs(excludedKeywords) do
        if string.find(itemName, keyword) then
            return true
        end
    end
    return false
end

-- Function to check if an item's name contains "Age" (for pets)
local function isPetItem(itemName)
    return string.find(itemName, "Age") ~= nil
end

-- Get all items in the player's backpack
local backpack = game:GetService("Players").LocalPlayer.Backpack
local itemCount = 0
local petCount = 0

-- Iterate through the backpack to count valid items and pets
for _, item in pairs(backpack:GetChildren()) do
    if item:IsA("Tool") then
        -- Count items not in the excluded list
        if not shouldExcludeItem(item.Name) then
            itemCount = itemCount + 1
        end

        -- Count pet items (those containing "Age" in their name)
        if isPetItem(item.Name) then
            petCount = petCount + 1
        end
    end
end

-- Create the RightGroupbox and labels

local ItemsLabel = RightGroupbox:AddLabel("Items: " .. itemCount)
local PetsLabel = RightGroupbox:AddLabel("Pets: " .. petCount)




--special top buttons 



local v1 = game.Players.LocalPlayer
local v2 = game:GetService("Players").LocalPlayer.PlayerGui.Teleport_UI.Frame.Pets -- Reference to the Pets ImageButton

-- Directly set the ImageButton to visible
v2.Visible = true  -- Makes the Pets ImageButton visible

-- Alternatively, you can also hide it like this (if needed in your executor):
-- v2.Visible = false  -- Makes it invisible




local v1 = game.Players.LocalPlayer
local v2 = game:GetService("Players").LocalPlayer.PlayerGui.Teleport_UI.Frame.Gear -- Reference to the Gear ImageButton

-- Directly set the ImageButton to visible
v2.Visible = true  -- Makes the Gear ImageButton visible

-- Alternatively, to hide it (if needed):
-- v2.Visible = false  -- Makes it invisible





--Crafting


local CraftingTab = Window:AddTab("Crafting", "hammer") -- Second parameter is the icon name (optional)



local LeftGroupbox = CraftingTab:AddLeftGroupbox("Toggless", "hammer")
local RightGroupbox = CraftingTab:AddRightGroupbox("Items", "hammer")

local selectedItem = nil
local isLooping = false

-- Normalize name helper
local function normalizeName(name)
    return name:lower()
end

-- Function to check if the item has the 'c' attribute
local function hasCAttribute(item)
    return item:GetAttribute("c") ~= nil
end

-- Special ItemType overrides by normalized name
local specialItemTypes = {
    ["lightning rod"] = "Lightning Rod"
}

-- Function to fire the "SetRecipe" remote for a given sprinkler or spray
local function fireSetRecipeRemote(sprinklerName)
    local args = {
        "SetRecipe",
        workspace:WaitForChild("Interaction"):WaitForChild("UpdateItems"):WaitForChild("CraftingTables"):WaitForChild("EventCraftingWorkBench"),
        "GearEventWorkbench",
        "Reclaimer"  -- Changed as per your update
    }

    local remoteEvent = game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("CraftingGlobalObjectService")
    if remoteEvent then
        print("Fired SetRecipe remote for '" .. sprinklerName .. "'")
        remoteEvent:FireServer(unpack(args))
    else
        print("Error: Remote event not found!")
    end
end

-- Function to fire the remote for an item, with correct ItemType depending on selectedItem and slot
function fireRemote(item, slot)
    if item then
        local uuid = item:GetAttribute("c")
        if not uuid then
            print("Error: Item " .. item.Name .. " does not have a valid 'c' attribute!")
            return
        end

        local nameLower = normalizeName(item.Name)

        -- Determine ItemType
        local itemType = "Holdable" -- default

        if (selectedItem == "Mutation Spray Choc" or selectedItem == "Mutation Spray Pollinated" or selectedItem == "Mutation Spray Shocked") and slot == 1 then
            itemType = "SprayBottle"
        elseif specialItemTypes[nameLower] then
            itemType = specialItemTypes[nameLower]
        elseif nameLower:find("sprinkler") then
            itemType = "Sprinkler"
        end

        local args = {
            "InputItem",
            workspace:WaitForChild("Interaction"):WaitForChild("UpdateItems"):WaitForChild("CraftingTables"):WaitForChild("EventCraftingWorkBench"),
            "GearEventWorkbench",
            slot,
            {
                ItemType = itemType,
                ItemData = {
                    UUID = uuid
                }
            }
        }

        local remoteEvent = game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("CraftingGlobalObjectService")
        if remoteEvent then
            print("Fired event for " .. item.Name .. " with UUID: " .. uuid .. " as " .. itemType)
            remoteEvent:FireServer(unpack(args))
        else
            print("Error: Remote event not found!")
        end
    end
end

-- Define item requirements for each sprinkler or spray
local itemRequirements = {
    ["Berry Blusher Sprinkler"] = {
        {"strawberry", 1},
        {"blueberry", 2},
        {"grape", 3},
        {"godly sprinkler", 4}
    },
    ["Tropical Mist Sprinkler"] = {
        {"coconut", 1},
        {"dragon fruit", 2},
        {"mango", 3},
        {"godly sprinkler", 4}
    },
    ["Spice Spritzer Sprinkler"] = {
        {"pepper", 1},
        {"amber lily", 2},
        {"cacao", 3},
        {"master sprinkler", 4}
    },
    ["Sweet Soaker Sprinkler"] = {
        {"watermelon", 1},
        {"watermelon", 2},
        {"watermelon", 3},
        {"master sprinkler", 4}
    },
    ["Flower Froster Sprinkler"] = {
        {"orange tulip", 1},
        {"daffodil", 2},
        {"advanced sprinkler", 3},
        {"basic sprinkler", 4}
    },
    ["Stalk Sprout Sprinkler"] = {
        {"bamboo", 1},
        {"beanstalk", 2},
        {"mushroom", 3},
        {"advanced sprinkler", 4}
    },
    ["Mutation Spray Choc"] = {
        {"cleaning spray", 1},
        {"cacao", 2}
    },
    ["Mutation Spray Pollinated"] = {
        {"cleaning spray", 1},
        {"bee balm", 2}
    },
    ["Mutation Spray Shocked"] = {
        {"cleaning spray", 1},
        {"lightning rod", 2}
    },
    ["Honey Crafters Crate"] = {
        {"bee crate", 1}
    },
    ["Anti Bee Egg"] = {
        {"bee egg", 1}
    },
    ["Pack Bee"] = {
        {"anti bee egg", 1},
        {"sunflower", 2},
        {"purple dahlia", 3}
    }
}

-- Function to scan the backpack and fire events based on selected recipe
function scanBackpack()
    local player = game.Players.LocalPlayer
    local backpack = player:WaitForChild("Backpack")
    local selected = selectedItem

    if not itemRequirements[selected] then
        print("No item requirements for selected item:", selected)
        return
    end
    print("Scanning for " .. selected .. " items...")

    local foundItems = {}

    for _, item in ipairs(backpack:GetChildren()) do
        local name = normalizeName(item.Name)
        if hasCAttribute(item) and not name:find("seed") then
            for _, req in ipairs(itemRequirements[selected]) do
                local keyword, slot = unpack(req)
                if not foundItems[slot] and name:find(keyword) then
                    foundItems[slot] = item
                    print("Found " .. keyword .. " for slot " .. slot .. ": " .. item.Name)
                    break
                end
            end
        end
    end

    for _, req in ipairs(itemRequirements[selected]) do
        local _, slot = unpack(req)
        if not foundItems[slot] then
            print("Missing required item for slot " .. slot .. ". Not firing events.")
            return
        end
    end

    print("All required items found! Firing events for " .. selected .. "...")
    fireSetRecipeRemote(selected)
    for slot, item in pairs(foundItems) do
        fireRemote(item, slot)
    end

    -- üî• Fire the Craft event after all items are sent
    local args = {
        "Craft",
        workspace:WaitForChild("Interaction"):WaitForChild("UpdateItems"):WaitForChild("CraftingTables"):WaitForChild("EventCraftingWorkBench"),
        "GearEventWorkbench"
    }
    local remoteEvent = game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("CraftingGlobalObjectService")
    if remoteEvent then
        print("Firing Craft event for " .. selected)
        remoteEvent:FireServer(unpack(args))
    else
        print("Error: Remote event not found!")
    end
end

-- Function to start the scanning loop
function startScanning()
    while isLooping do
        scanBackpack()
        wait(1)
    end
end

-- Dropdown to select sprinkler type or spray
Dropdown = RightGroupbox:AddDropdown("MyDropdown", {
    Values = {
        "None",
        "Tropical Mist Sprinkler",
        "Berry Blusher Sprinkler",
        "Spice Spritzer Sprinkler",
        "Sweet Soaker Sprinkler",
        "Flower Froster Sprinkler",
        "Stalk Sprout Sprinkler",
        "Mutation Spray Choc",
        "Mutation Spray Pollinated",
        "Mutation Spray Shocked",
        "Honey Crafters Crate",
        "Anti Bee Egg",
        "Pack Bee"
    },
    Default = 1,
    Multi = false,
    Text = "Select an Item",
    Tooltip = "This is a dropdown",
    Callback = function(Value)
        print("Dropdown selected:", Value)
        selectedItem = Value
    end
})

-- Toggle for starting/stopping the loop
MyToggle = LeftGroupbox:AddToggle("MyToggle", {
    Text = "Start/Stop Gear Craft",
    Default = false,
    Tooltip = "This is a toggle to start/stop looping",
    Callback = function(Value)
        print("Toggle changed to:", Value)

        if itemRequirements[selectedItem] then
            if Value then
                print("Starting loop for " .. selectedItem)
                isLooping = true
                spawn(startScanning)
            else
                print("Stopping loop for " .. selectedItem)
                isLooping = false
            end
        else
            print("Looping is not allowed for the selected item.")
            isLooping = false
        end
    end
})


--






















--seed craft logic 




selectedSeedItem = nil
isSeedLooping = false

-- Check for 'c' attribute
function hasCAttributeSeed(item)
    return item:GetAttribute("c") ~= nil
end

-- Fire SetRecipe for seeds
function fireSetSeedRecipeRemote(seedPackName)
    local args = {
        "SetRecipe",
        workspace:WaitForChild("Interaction"):WaitForChild("UpdateItems"):WaitForChild("CraftingTables"):WaitForChild("SeedEventCraftingWorkBench"),
        "SeedEventWorkbench",
        seedPackName
    }

    local remoteEvent = game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("CraftingGlobalObjectService")
    if remoteEvent then
        print("Fired Seed SetRecipe remote for '" .. seedPackName .. "'")
        remoteEvent:FireServer(unpack(args))
    else
        print("Error: Seed remote event not found!")
    end
end

-- Fire InputItem for a seed or holdable
function fireSeedRemote(item, slot, itemType)
    if item then
        local uuid = item:GetAttribute("c")
        if not uuid then
            print("Error: Item " .. item.Name .. " does not have a valid 'c' attribute!")
            return
        end

        local args = {
            "InputItem",
            workspace:WaitForChild("Interaction"):WaitForChild("UpdateItems"):WaitForChild("CraftingTables"):WaitForChild("SeedEventCraftingWorkBench"),
            "SeedEventWorkbench",
            slot,
            {
                ItemType = itemType,
                ItemData = {
                    UUID = uuid
                }
            }
        }

        local remoteEvent = game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("CraftingGlobalObjectService")
        if remoteEvent then
            print("Fired item input for " .. item.Name .. " (Type: " .. itemType .. ") with UUID: " .. uuid)
            remoteEvent:FireServer(unpack(args))
        else
            print("Error: Remote event not found!")
        end
    end
end

-- Fire Craft remote after inputs
function fireSeedCraftRemote()
    local args = {
        "Craft",
        workspace:WaitForChild("Interaction"):WaitForChild("UpdateItems"):WaitForChild("CraftingTables"):WaitForChild("SeedEventCraftingWorkBench"),
        "SeedEventWorkbench"
    }
    local remoteEvent = game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("CraftingGlobalObjectService")
    remoteEvent:FireServer(unpack(args))
end

-- Seed item requirements with itemType
seedItemRequirements = {
    ["Crafters Seed Pack"] = {
        {"flower seed pack", 1, "Seed Pack"}
    },
    ["Manuka Flower"] = {
        {"daffodil seed", 1, "Seed"},
        {"orange tulip seed", 2, "Seed"}
    },
    ["Dandelion"] = {
        {"bamboo", 1, "Holdable"},
        {"bamboo", 2, "Holdable"},
        {"manuka flower", 3, "Seed"}
    },
    ["Lumira"] = {
        {"pumpkin", 1, "Holdable"},
        {"pumpkin", 2, "Holdable"},
        {"dandelion seed", 3, "Seed"},
        {"flower seed pack", 4, "Seed Pack"}
    },
    ["Honeysuckle"] = {
        {"pink lily seed", 1, "Seed"},
        {"purple dahlia seed", 2, "Seed"}
    },
    ["Bee Balm"] = {
        {"crocus", 1, "Holdable"},
        {"lavender", 2, "Holdable"}
    },
    ["Nectar Thorn"] = {
        {"cactus", 1, "Holdable"},
        {"cactus", 2, "Holdable"},
        {"cactus seed", 3, "Seed"},
        {"nectarshade seed", 4, "Seed"}
    },
    ["Suncoil"] = {
        {"crocus", 1, "Holdable"},
        {"daffodil", 2, "Holdable"},
        {"dandelion", 3, "Holdable"},
        {"pink lily", 4, "Holdable"}
    }
}

-- Backpack scanner for matching items
function scanSeedBackpack()
    local player = game.Players.LocalPlayer
    local backpack = player:WaitForChild("Backpack")
    local selected = selectedSeedItem

    if not seedItemRequirements[selected] then
        print("No seed item requirements for selected item:", selected)
        return
    end
    print("Scanning for " .. selected .. " crafting items...")

    local foundItems = {}

    -- Try to find all required items
    for _, req in ipairs(seedItemRequirements[selected]) do
        local keyword, slot, itemType = unpack(req)
        for _, item in ipairs(backpack:GetChildren()) do
            local name = item.Name:lower()
            if hasCAttributeSeed(item) and not foundItems[slot] and name:find(keyword) then
                foundItems[slot] = { item = item, itemType = itemType }
                print("Found " .. keyword .. " for slot " .. slot .. ": " .. item.Name .. " (" .. itemType .. ")")
                break
            end
        end
    end

    -- Check if all required slots are filled
    local allFound = true
    for _, req in ipairs(seedItemRequirements[selected]) do
        local _, slot = unpack(req)
        if not foundItems[slot] then
            print("Missing item for slot " .. slot .. ". Cannot craft " .. selected)
            allFound = false
        end
    end

    if allFound then
        print("All items found! Firing crafting events for " .. selected .. "...")

        -- Fire SetRecipe remote
        fireSetSeedRecipeRemote(selected)

        -- Fire InputItem remote for each found item
        for slot, data in pairs(foundItems) do
            fireSeedRemote(data.item, slot, data.itemType)
        end

        -- Fire the Craft remote
        fireSeedCraftRemote()
    else
        print("Not all required items found. Skipping crafting.")
    end
end

-- Continuous scanning loop
function startSeedScanning()
    while isSeedLooping do
        scanSeedBackpack()
        wait(1)
    end
end

-- Dropdown for selecting seed item
SeedDropdown = RightGroupbox:AddDropdown("SeedDropdown", {
    Values = {
        "None",
        "Crafters Seed Pack",
        "Manuka Flower",
        "Dandelion",
        "Lumira",
        "Honeysuckle",
        "Bee Balm",
        "Nectar Thorn",
        "Suncoil"
    },
    Default = 1,
    Multi = false,
    Text = "Select a Seed Item",
    Tooltip = "Select seed pack to craft",
    Callback = function(Value)
        print("Seed Dropdown selected:", Value)
        selectedSeedItem = Value
    end
})

-- Toggle to control scanning loop
SeedToggle = LeftGroupbox:AddToggle("SeedToggle", {
    Text = "Start/Stop Seed Looping",
    Default = false,
    Tooltip = "Toggle seed crafting loop",
    Callback = function(Value)
        print("Seed Toggle changed to:", Value)

        if seedItemRequirements[selectedSeedItem] then
            if Value then
                print("Starting seed loop for " .. selectedSeedItem)
                isSeedLooping = true
                spawn(startSeedScanning)
            else
                print("Stopping seed loop for " .. selectedSeedItem)
                isSeedLooping = false
            end
        else
            print("Seed looping is not allowed for the selected item.")
            isSeedLooping = false
        end
    end
})
















--AUTOCLAIM SEED TOGGLE


local runService = game:GetService("RunService")

MyToggle = LeftGroupbox:AddToggle("MyToggle", {
    Text = "Claim Seed After Timer",
    Default = false,
    Tooltip = "Skip Timer For Seed Craft",
    Callback = function(Value)
        if Value then
            task.spawn(function()
                while MyToggle.Value do
                    local args = {
                        "Craft",
                        workspace:WaitForChild("Interaction"):WaitForChild("UpdateItems"):WaitForChild("NewCrafting"):WaitForChild("SeedEventCraftingWorkBench"),
                        "SeedEventWorkbench"
                    }
                    game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("CraftingGlobalObjectService"):FireServer(unpack(args))

                    task.wait(0.5)
                end
            end)
        end
    end
})



--AUTOCLAIM GEAR TOGGLE





local toggleState = false

MyToggle = LeftGroupbox:AddToggle("MyToggle", {
    Text = "Claim Gear After Timer",
    Default = false,
    Tooltip = "Skip Gear Craft Timer For Free",
    Callback = function(Value)
        toggleState = Value
        print("Toggle changed to:", Value)

        if Value then
            coroutine.wrap(function()
                while toggleState do
                    local args = {
                        "Claim",
                        workspace:WaitForChild("Interaction"):WaitForChild("UpdateItems"):WaitForChild("NewCrafting"):WaitForChild("EventCraftingWorkBench"),
                        "GearEventWorkbench",
                        1
                    }
                    game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("CraftingGlobalObjectService"):FireServer(unpack(args))
                    wait(0.5)
                end
            end)()
        end
    end
})





























-- Dropdown in RightGroupbox with added options
RightGroupbox:AddDropdown("MyDropdown", {
    Values = {
        "Tropical Mist Sprinkler", 
        "Berry Blusher Sprinkler", 
        "Spice Spritzer Sprinkler",
        "Sweet Soaker Sprinkler",
        "Flower Froster Sprinkler",
        "Stalk Sprout Sprinkler",
        "Mutation Spray Choc",
        "Mutation Spray Pollinated",
        "Mutation Spray Shocked",
        "Honey Crafters Crate",
        "Anti Bee Egg",
        "Pack Bee"
    },
    Default = 1, -- Default to Tropical Mist Sprinkler
    Multi = false, -- Single selection only
    Text = "Select Gear Recipe",
    Tooltip = "This is a dropdown",
    Callback = function(Value)
        print("Dropdown new value:", Value)
        
        -- Assign the selected sprinkler based on dropdown value
        RightGroupbox.SelectedSprinkler = Value -- Directly use the selected value from the dropdown
    end
})

-- Default selected option based on dropdown default (Option 1)
RightGroupbox.SelectedSprinkler = "Tropical Mist Sprinkler"

-- Toggle in LeftGroupbox
LeftGroupbox:AddToggle("MyToggle", {
    Text = "Craft Selected Gear Recipe",
    Default = false,
    Tooltip = "This is a toggle",
    Callback = function(Value)
        print("Toggle changed to:", Value)

        -- Check if the toggle is enabled (Value is true)
        if Value then
            -- Get the currently selected sprinkler from the dropdown
            local selectedSprinkler = RightGroupbox.SelectedSprinkler

            -- Fire the appropriate event based on the selected sprinkler
            local args = {
                "SetRecipe",
                workspace:WaitForChild("Interaction"):WaitForChild("UpdateItems"):WaitForChild("NewCrafting"):WaitForChild("EventCraftingWorkBench"),
                "GearEventWorkbench",
                selectedSprinkler
            }

            -- Fire the remote event with the arguments
            game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("CraftingGlobalObjectService"):FireServer(unpack(args))
        end
    end
})


--Select Seed recipe


-- New Dropdown in RightGroupbox for Seed Recipes
RightGroupbox:AddDropdown("MySeedDropdown", {
    Values = {
        "Crafters Seed Pack",
        "Manuka Flower",
        "Dandelion",
        "Lumira",
        "Honeysuckle",
        "Bee Balm",
        "Nectar Thorn",
        "Suncoil"
    },
    Default = 1, -- Default to "Crafters Seed Pack"
    Multi = false,
    Text = "Select Seed Recipe",
    Tooltip = "Choose a seed crafting recipe",
    Callback = function(Value)
        print("Seed dropdown selected:", Value)
        RightGroupbox.SelectedSeedRecipe = Value
    end
})

-- Default selected seed recipe
RightGroupbox.SelectedSeedRecipe = "Crafters Seed Pack"


-- New Toggle in LeftGroupbox to trigger crafting for seeds
LeftGroupbox:AddToggle("MySeedToggle", {
    Text = "Craft Selected Seed Recipe",
    Default = false,
    Tooltip = "Toggle to craft the selected seed recipe",
    Callback = function(Value)
        print("Seed toggle changed:", Value)

        if Value then
            local selectedSeed = RightGroupbox.SelectedSeedRecipe or "Suncoil" -- fallback if nil

            local args = {
                "SetRecipe",
                workspace:WaitForChild("Interaction"):WaitForChild("UpdateItems"):WaitForChild("NewCrafting"):WaitForChild("SeedEventCraftingWorkBench"),
                "SeedEventWorkbench",
                selectedSeed
            }

            game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("CraftingGlobalObjectService"):FireServer(unpack(args))
        end
    end
})







--cancel craft recipe
Button = LeftGroupbox:AddButton({
    Text = "Cancel Craft Gear",
    Func = function()
        -- Print when the button is clicked
        

        -- Define the args for the event
        local args = {
            "Cancel",
            workspace:WaitForChild("Interaction"):WaitForChild("UpdateItems"):WaitForChild("NewCrafting"):WaitForChild("EventCraftingWorkBench"),
            "GearEventWorkbench"
        }

        -- Fire the server event
        game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("CraftingGlobalObjectService"):FireServer(unpack(args))
    end,
    DoubleClick = true -- Requires double-click for risky actions
})




--Cancel Craft Seed

Button = LeftGroupbox:AddButton({
    Text = "Cancel Craft Seed",
    Func = function()
        

        local args = {
            "Cancel",
            workspace:WaitForChild("Interaction"):WaitForChild("UpdateItems"):WaitForChild("NewCrafting"):WaitForChild("SeedEventCraftingWorkBench"),
            "SeedEventWorkbench"
        }
        game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("CraftingGlobalObjectService"):FireServer(unpack(args))
    end,
    DoubleClick = true -- Requires double-click for risky actions
})




-------------------------------------------
--===========SEEDSTOCK=============--     /
-------------------------------------------













































--PETS TAB LOGIC


--auto feed logic Timer based with label for pet stats

PetsTab = Window:AddTab("Pets", "paw-print")
RightGroupbox = PetsTab:AddRightGroupbox("Info", "info")
LeftGroupbox = PetsTab:AddLeftGroupbox("Feed Toggle", "beef")

fruitsList = {
    "All DOUBLE CLICK!", "None DOUBLE CLICK!",
    "Carrot", "Strawberry", "Blueberry", "Orange Tulip", "Tomato", "Corn", "Daffodil",
    "Watermelon", "Pumpkin", "Apple", "Bamboo", "Coconut", "Cactus", "Dragon Fruit", "Mango", 
    "Grape", "Mushroom", "Pepper", "Cacao", "Beanstalk", "EmberLily", "Sugar Apple"
}

petsDropdownValues = {
    "All DOUBLE CLICK!", "None DOUBLE CLICK!"
}

MyToggle = LeftGroupbox:AddToggle("MyToggle", {
    Text = "Auto Equip Fruits",
    Default = false,
    Tooltip = "Toggle to start/stop auto equipping fruits",
    Callback = function(Value)
        print("Equip Toggle changed to:", Value)
        
        if Value then
            startEquipCycle()  -- Start the cycle of equipping fruits
        else
            stopEquipCycle()   -- Stop the cycle of equipping fruits
        end
    end
})

PetsDropdown = LeftGroupbox:AddDropdown("PetsDropdown", {
    Values = petsDropdownValues,
    Default = {["All DOUBLE CLICK!"] = false, ["None DOUBLE CLICK!"] = true},
    Multi = true,
    Text = "Pets",
    Tooltip = "Select pets",
})

FruitsDropdown = LeftGroupbox:AddDropdown("FruitsDropdown", {
    Values = fruitsList,
    Default = {["All DOUBLE CLICK!"] = false, ["None DOUBLE CLICK!"] = true},
    Multi = true,
    Text = "Fruits (Equip Only)",
    Tooltip = "Select fruits to equip (No effect on feeding)",
})

function selectAll(dropdown, select)
    for _, item in ipairs(dropdown.Values) do
        if item ~= "All DOUBLE CLICK!" and item ~= "None DOUBLE CLICK!" then
            dropdown.Value[item] = select
        end
    end
end

function updateAllNoneSelection(dropdown)
    local vals = dropdown.Value
    if vals["All DOUBLE CLICK!"] then
        vals["None DOUBLE CLICK!"] = false
        selectAll(dropdown, true)
    elseif vals["None DOUBLE CLICK!"] then
        vals["All DOUBLE CLICK!"] = false
        selectAll(dropdown, false)
    else
        vals["All DOUBLE CLICK!"] = false
        vals["None DOUBLE CLICK!"] = false
    end
end

PetsDropdown.Callback = function()
    updateAllNoneSelection(PetsDropdown)
end

FruitsDropdown.Callback = function()
    updateAllNoneSelection(FruitsDropdown)
end

RightGroupbox:AddLabel("Your Pets")

function ScanAndDisplayPets()
    petsDropdownValues = {"All DOUBLE CLICK!", "None DOUBLE CLICK!"}

    local index = 1
    for _, child in ipairs(game:GetService("Players").LocalPlayer.PlayerGui.ActivePetUI.Frame.Main.ScrollingFrame:GetChildren()) do
        if child:IsA("Frame") and child.Visible == true then
            if child:FindFirstChild("PET_NAME") and child:FindFirstChild("PET_TYPE") and child:FindFirstChild("PET_AGE") then
                local label = RightGroupbox:AddLabel({
                    Text = "",
                    DoesWrap = true
                })

                local function updateText()
                    label:SetText(
                        "Pet " .. index .. " - UUID: " .. child.Name .. "\n" ..
                        "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n" ..
                        "Name: " .. child.PET_NAME.Text .. "\n" ..
                        "Age: " .. child.PET_AGE.Text .. "\n" ..
                        "Type: " .. child.PET_TYPE.Text .. "\n" ..
                        "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
                    )
                end

                updateText()

                child.PET_NAME:GetPropertyChangedSignal("Text"):Connect(updateText)
                child.PET_TYPE:GetPropertyChangedSignal("Text"):Connect(updateText)

                local lastAgeText = child.PET_AGE.Text

                game:GetService("RunService").Heartbeat:Connect(function()
                    if child.PET_AGE.Text ~= lastAgeText then
                        lastAgeText = child.PET_AGE.Text
                        updateText()
                    end
                end)

                table.insert(petsDropdownValues, child.PET_NAME.Text .. " (" .. child.Name .. ")")

                index = index + 1
            end
        end
    end

    PetsDropdown:SetValues(petsDropdownValues)
    PetsDropdown.Value = {["None DOUBLE CLICK!"] = true}
end

ScanAndDisplayPets()

-- Function to extract the core fruit name (ignoring descriptors like [Moonlit], [0.24kg], etc.)
function extractFruitName(itemName)
    -- Remove square brackets and anything inside them
    local cleanName = itemName:gsub("%b[]", "")  -- Remove content inside brackets (e.g. [Moonlit])
    cleanName = cleanName:gsub("%s+", " "):match("^%s*(.-)%s*$")  -- Clean up extra spaces
    return cleanName
end

-- Fuzzy matching function: Checks if the core fruit name matches the query
function fuzzyMatch(itemName, query)
    local cleanItemName = extractFruitName(itemName):lower()  -- Get the cleaned fruit name
    local cleanQuery = query:lower()  -- Lowercase the query for case-insensitive comparison
    
    return string.find(cleanItemName, cleanQuery, 1, true) ~= nil  -- Use exact string matching
end

-- Function to get fruits in the backpack that do not have the 'd' attribute set to true
function getFruitsInBackpack()
    local inventory = game:GetService("Players").LocalPlayer.Backpack:GetChildren()
    local fruits = {}

    for _, item in ipairs(inventory) do
        if item:IsA("Tool") and not string.find(item.Name:lower(), "seed") then
            -- Check if the 'd' attribute is set to true
            if item:GetAttribute("d") == true then
                -- Skip this item if 'd' attribute is enabled
                continue
            end
            -- If the tool doesn't have the 'd' attribute enabled, add it to the fruits list
            table.insert(fruits, item.Name)
        end
    end

    return fruits
end

-- Function to equip the fruit by its name (ensure it doesn't have 'd' enabled)
function equipFruitByName(fruitName)
    local inventory = game:GetService("Players").LocalPlayer.Backpack:GetChildren()
    for _, item in ipairs(inventory) do
        if item:IsA("Tool") and not string.find(item.Name:lower(), "seed") then
            -- Check if the 'd' attribute is set to true
            if item:GetAttribute("d") == true then
                -- Skip this item if 'd' attribute is enabled
                continue
            end

            local extractedFruitName = extractFruitName(item.Name)  -- Extract the clean fruit name
            if fuzzyMatch(extractedFruitName, fruitName) then
                game:GetService("Players").LocalPlayer.Character.Humanoid:EquipTool(item)
                return item
            end
        end
    end
    return nil
end

function unequipFruit()
    local humanoid = game:GetService("Players").LocalPlayer.Character and game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid:UnequipTools()
    end
end

function equipSelectedFruits()
    local selectedFruits = {}
    for fruit, isSelected in pairs(FruitsDropdown.Value) do
        if isSelected and fruit ~= "All DOUBLE CLICK!" and fruit ~= "None DOUBLE CLICK!" then
            table.insert(selectedFruits, fruit)
        end
    end

    local fruitsInBackpack = getFruitsInBackpack()

    for _, fruitName in ipairs(selectedFruits) do
        equipFruitByName(fruitName)
    end
end

-- Function to check if there is only one fruit left in the backpack
function hasOneFruitLeftInBackpack()
    local fruitsInBackpack = getFruitsInBackpack()
    return #fruitsInBackpack == 1
end

-- Function to feed the pet
function feedPet(uuid)
    local args = {
        "Feed",
        uuid  -- The pet UUID passed from the selection
    }
    game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("ActivePetService"):FireServer(unpack(args))
end

-- Function to start the equip cycle
function startEquipCycle()
    if equipCycleRunning then
        return
    end

    equipCycleRunning = true
    local feedCount = 0  -- Keep track of feed count for each pet

    local selectedPets = {}
    for petEntry, isSelected in pairs(PetsDropdown.Value) do
        if isSelected and petEntry ~= "All DOUBLE CLICK!" and petEntry ~= "None DOUBLE CLICK!" then
            local uuid = petEntry:match("%((.-)%)")
            if uuid then
                table.insert(selectedPets, uuid)
            end
        end
    end

    -- Start cycling through pets
    local currentPetIndex = 1
    while equipCycleRunning do
        -- If only 1 fruit is left in the backpack, stop the cycle
        if hasOneFruitLeftInBackpack() then
            print("Only 1 fruit left in the backpack. Pausing cycle.")
            break
        end

        equipSelectedFruits()

        -- Get the current pet UUID to feed
        local currentPetUUID = selectedPets[currentPetIndex]

        -- Feed the current selected pet 3 times
        feedCount = 0
        while feedCount < 3 do
            feedPet(currentPetUUID)
            feedCount = feedCount + 1
            wait(0.3)  -- Wait 0.3 seconds before feeding again
        end

        -- Move to the next pet
        currentPetIndex = currentPetIndex + 1
        if currentPetIndex > #selectedPets then
            -- Reset to the first pet if we reach the end of the list
            currentPetIndex = 1
        end

        wait(1)  -- Wait before trying again
    end

    -- Monitor backpack for more fruits and restart if there are more than 1
    while equipCycleRunning do
        if #getFruitsInBackpack() > 1 then
            startEquipCycle()  -- Restart the cycle if more fruits are available
            break
        end
        wait(1)  -- Wait before checking again
    end
end

-- Function to stop the equip cycle
function stopEquipCycle()
    equipCycleRunning = false
end






















------------------------------------------
--===========WEATHERHOOK=============--  
------------------------------------------
local WebHookTab = Window:AddTab("WebHook", "link")
local LeftGroupbox = WebHookTab:AddLeftGroupbox("Weather Track", "cloud-moon-rain")
local HttpService = game:GetService("HttpService")

-- Default URLs and Role IDs
local weatherWebhookUrl = ""
local eggWebhookUrl = ""

local weatherRoleId = ""
local eggRoleId = ""

-- Event Descriptions
local eventDescriptions = {
    RainEvent = "Rain increases Growth Speed and has a 50% chance to make the fruit Wet (2x). The mutation applies even if the fruit just entered rain. Est:75%",
    FrostEvent = "Increases Growth speed and has a chance to make the fruit Chilled (2x). If a crop has both the Wet mutation and the Chilled mutation, the fruit will get the Frozen mutation (10x). Est:17.5%",
    Thunderstorm = "Increases Growth Speed by 50%, has a 50% chance to make the fruit Wet (2x), and if hit by lightning makes the fruit Shocked (100x). Est:7.5% (10% of Rain)",
    NightEvent = "Gives fruits a glowing purple hue and has a chance of making fruit Moonlit (2x). By default, 6 crops become moonlit per night. The Night event occurs every hour and lasts ~10 minutes.",
    BloodMoonEvent = "Fruit can become Bloodlit with enhanced properties. This is a rare and powerful event.",
    MeteorShower = "If crops are hit by meteors, they gain the Celestial mutation (120x value) and take on a bluish tint.",
    MonsterMash = "MonsterMash event is active! Be ready for spooky fun!",
    DJJhai = "DJJhai event activates party visuals, music, and dance effects.",
    TornadoEvent = "Tornado event active! Watch out for tornadoes causing effects in the area.",
    DiscoEvent = "Disco event activates colorful party visuals and Disco Mutation.",
    JanzenStorm = "JanzenStorm causes intense weather visuals, shaking, lighting, and cloud cover effects. Rare storm event.",
    JandelLazer = "JandelLazer activates laser visuals with shaking, color correction, and target-based animation. Rare and intense!",
    ChocolateRain = "ChocolateRain is falling! Watch out for sweet weather effects!",
    Blackhole = "Blackhole event active! Intense gravity and visual effects in play.",
    Beestorm = "Beestorm is active! Bees are swarming and honey rain is falling. Expect vibrant visuals and a buzzing atmosphere.",
    BeenadoEvent = "Beenado event is active! Tornado of bees causing effects and atmospheric changes.",
    BeeSwarm = "Bees are swarming the fields! Expect increased pollination and buzzing effects.",
    Windy = "Windy event increases pollination and rustles the crops. Expect breezy weather conditions.",
    SunGod = "The SunGod event is active! Prepare for intense sun effects, extreme brightness, and visual changes.",
    Rainbow = "The Rainbow event is active! Colorful effects fill the sky as a radiant rainbow swirls and transforms the atmosphere.",
    JandelFloat = "The JandelFloat event is active! Prepare for unique floating effects and gravity alterations.",
    Volcano = "The Volcano event is active! Watch as the volcano erupts with fiery explosions, ash, and intense visuals.",
    MeteorStrike = "Meteor Strike event is active! Prepare for falling meteors, intense visuals, and explosive impacts. The sky will darken and tremors will shake the world.",
    Gale = "Gale event active! A strong wind is sweeping through the area, causing a significant atmospheric change.",
    AlienInvasionEvent = "Alien Invasion is underway! Mysterious extraterrestrial forces are invading the skies, causing strange visual and atmospheric effects.",
    HeatwaveEvent = "Heatwave event is active! Expect intense lighting changes and warmer, harsher atmospheric conditions.",
    SpaceTravelEvent = "The Space Travel event is active! Expect intense atmospheric changes and gravity alterations as you journey through space!",
    SummerEvent = "A bright and lively summer event with music, lights, and fireworks!",  -- Summer Event description
    SummerHarvest = "The SummerHarvest event is here! Vibrant effects, fruity visuals, and boiling weather fill the atmosphere. A time for bounty and celebration!",  -- SummerHarvest description
    UnderTheSea = "A mysterious underwater phenomenon has begun! The world is submerged as water levels rise." -- New UnderTheSea event description
}

-- Event end messages
local eventEndDescriptions = {
    RainEvent = "Rain event has ended...",
    FrostEvent = "Frost event ended...",
    Thunderstorm = "Thunderstorm cleared...",
    NightEvent = "Night event ended...",
    BloodMoonEvent = "Blood Moon has passed...",
    MeteorShower = "Meteor Shower has ended. Sky is clear and effects are removed.",
    MonsterMash = "MonsterMash event ended...",
    DJJhai = "DJJhai event has ended, visuals and effects cleared.",
    TornadoEvent = "Tornado event has ended.",
    DiscoEvent = "Disco event has ended.",
    JanzenStorm = "JanzenStorm has passed. Skies are clear again.",
    JandelLazer = "JandelLazer has ended. Visuals cleared and effects disabled.",
    ChocolateRain = "ChocolateRain has stopped. The skies are clear.",
    Blackhole = "Blackhole event has ended. Gravity and visuals restored.",
    Beestorm = "Beestorm has ended. The skies are clear and the bees have gone.",
    BeenadoEvent = "Beenado event has ended. The skies have calmed.",
    BeeSwarm = "Bee Swarm event has ended. The bees have returned to their hives.",
    Windy = "Windy event has ended.",
    SunGod = "The SunGod event has ended. The sky returns to normal.",
    Rainbow = "Rainbow event has ended. The skies have cleared.",
    JandelFloat = "JandelFloat event has ended. Gravity and visuals returned to normal.",
    Volcano = "Volcano event has ended. The eruption subsides and the skies clear.",
    MeteorStrike = "Meteor Strike event has ended. The meteors have stopped falling and the sky clears.",
    Gale = "Gale event has ended. The strong winds have subsided.",
    AlienInvasionEvent = "Alien Invasion has ended. The extraterrestrial forces have left the skies.",
    HeatwaveEvent = "Heatwave event has passed. The lighting returns to normal.",
    SpaceTravelEvent = "The Space Travel event has ended. Gravity and visuals return to normal.",
    SummerEvent = "The Summer Event has ended, and the fireworks have subsided.",  -- SummerEvent end message
    SummerHarvest = "The SummerHarvest event has ended. The skies clear and the visuals fade.", -- SummerHarvest end message
    UnderTheSea = "UnderTheSea event has ended. The water levels have returned to normal." -- New UnderTheSea event end message
}

-- Emojis
local eventEmojis = {
    RainEvent = "üåß",
    FrostEvent = "‚ùÑÔ∏è",
    Thunderstorm = "‚õàÔ∏è",
    NightEvent = "üåï",
    BloodMoonEvent = "ü©∏",
    MeteorShower = "üü†",
    MonsterMash = "üéÉ",
    DJJhai = "üéâ",
    TornadoEvent = "üå™Ô∏è",
    DiscoEvent = "üéâ",
    JanzenStorm = "‚ö°",
    JandelLazer = "üî¥",
    ChocolateRain = "üç´",
    Blackhole = "üï≥Ô∏è",
    Beestorm = "üêù",
    BeenadoEvent = "üêùüå™Ô∏è",
    BeeSwarm = "üêù",
    Windy = "üå¨Ô∏è",
    SunGod = "üåû",
    Rainbow = "üåà",
    JandelFloat = "üéà",
    Volcano = "üåã",
    MeteorStrike = "‚òÑÔ∏è",
    Gale = "üí®",
    AlienInvasionEvent = "üëΩ",
    HeatwaveEvent = "üî•",
    SpaceTravelEvent = "üöÄ",
    SummerEvent = "üåûüéÜ",  -- Summer event emoji
    SummerHarvest = "üçâüåû",  -- SummerHarvest emoji
    UnderTheSea = "üåä" -- New UnderTheSea event emoji
}

-- Role Mentions
local roleMentions = {
    RainEvent = "<@&1373733906158715072>",
    Thunderstorm = "<@&1373734066163159163>",
    FrostEvent = "<@&1373734683501793322>",
    NightEvent = "<@&1373734291795873965>",
    MeteorShower = "<@&1373734868713996419>",
    BloodMoonEvent = "<@&1382766134536966316>",
    DiscoEvent = "<@&1382013571122200586>",
    JanzenStorm = "<@&1382007680503255171>",
    JandelLazer = "<@&1382008108385308722>",
    DJJhai = "<@&1382008924592410634>",
    TornadoEvent = "<@&1382009331901272225>",
    MonsterMash = "<@&1382009842172170363>",
    Blackhole = "<@&1382010519543615619>",
    Beestorm = "<@&1381317357095489768>",
    BeenadoEvent = "<@&1362357253033820313>",
    BeeSwarm = "<@&1381317357095489768>",
    Windy = "<@&1382009944508731443>",
    SunGod = "<@&1382011024839807099>",
    Rainbow = "<@&1382620952749388906>",
    JandelFloat = "<@&1382011258013880462>",
    Volcano = "<@&1383329120636764230>",
    MeteorStrike = "<@&1383329584648290364>",
    Gale = "<@&1385959238718849224>",
    AlienInvasionEvent = "<@&1385959318485995700>",
    HeatwaveEvent = "<@&1385958700220420216>",
    SpaceTravelEvent = "<@&1385959124097044714>",
    SummerEvent = "<@&1385958837218971698>",  -- SummerEvent role mention
    SummerHarvest = "<@&1385958837218971698>", -- SummerHarvest role mention
    UnderTheSea = "<@&1385959395506131008>" -- New UnderTheSea role mention
}


-- Function to send webhook for weather events
local function sendWeatherWebhook(eventName, isActive)
    local emoji = eventEmojis[eventName] or "üü†"
    local displayName = eventName
    local statusText = isActive and "Active" or "Ended"
    local descriptionText = eventDescriptions[eventName] or ""
    local color = isActive and 0x1A2B5C or 0x5C1A2B  -- Darker colors for event end
    local mention = ""

    if isActive and roleMentions[eventName] then
        mention = roleMentions[eventName]
    end

    local embedDescription = emoji .. " " .. displayName
    if descriptionText ~= "" then
        embedDescription = embedDescription .. "\n\nDescription: " .. descriptionText
    end

    local data = {
        content = mention,
        embeds = { {
            title = "Weather Event " .. statusText,
            description = embedDescription,
            color = color,
            footer = { text = "Event ID: " .. eventName },
            timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
        } }
    }

    local jsonData = HttpService:JSONEncode(data)

    -- Send webhook
    local requestFunction = http_request or (syn and syn.request) or (http and http.request)
    if not requestFunction then
        warn("[Webhook] No HTTP request function available!")
        return
    end

    local success, err = pcall(function()
        requestFunction({
            Url = weatherWebhookUrl,
            Method = "POST",
            Headers = {
                ["Content-Type"] = "application/json"
            },
            Body = jsonData
        })
    end)

    if not success then
        warn("[Webhook] Failed: " .. tostring(err))
    else
        print("[Webhook] Sent:", eventName, "Status:", statusText)
    end
end

-- Weather tracking connections
local weatherConnections = {}

local function startWeatherTracking()
    local function connect(attributeName)
        local conn = workspace:GetAttributeChangedSignal(attributeName):Connect(function()
            local isActive = workspace:GetAttribute(attributeName)
            sendWeatherWebhook(attributeName, isActive)
        end)
        table.insert(weatherConnections, conn)

        -- Send initial state if active
        if workspace:GetAttribute(attributeName) then
            sendWeatherWebhook(attributeName, true)
        end
    end

    -- List of weather events to track, including the new SummerHarvest event
    local weatherEvents = {
        "RainEvent", "Thunderstorm", "FrostEvent", "NightEvent", "BloodMoonEvent", "MeteorShower",
        "MonsterMash", "DJJhai", "TornadoEvent", "DiscoEvent", "JanzenStorm", "JandelLazer", 
        "ChocolateRain", "Blackhole", "Beestorm", "BeenadoEvent", "BeeSwarm", "Windy", "SunGod", "JandelFloat", 
        "Volcano", "MeteorStrike", "Gale", "AlienInvasionEvent", "HeatwaveEvent", "SpaceTravelEvent", "SummerEvent", "SummerHarvest", "UnderTheSea"
    }

    for _, event in pairs(weatherEvents) do
        connect(event)
    end
end

-- Stop tracking on script disable
local function stopWeatherTracking()
    for _, conn in ipairs(weatherConnections) do
        conn:Disconnect()
    end
    print("[Weather Tracker] Disabled")
end

-- UI Toggle for Weather Webhooks
LeftGroupbox:AddToggle("WeatherToggle", {
    Text = "Enable Weather Webhooks",
    Default = false,
    Tooltip = "Toggle to start/stop weather event webhook reporting.",
    Callback = function(Value)
        if Value then
            startWeatherTracking()
        else
            stopWeatherTracking()
        end
    end
})








----------------------------------------
--===========EGGHOOK=============--    
----------------------------------------
sendingLoopRunning = false
sendingLoopThread = nil
lastStockSnapshot = {}

HttpService = game:GetService("HttpService")
DataService_upvr = require(game:GetService("ReplicatedStorage").Modules.DataService)
PetEggData_upvr = require(game:GetService("ReplicatedStorage").Data.PetEggData)
http_request = (syn and syn.request) or http_request or http.request

roleIds = {
    common = "1373741681286840380",
    uncommon = "1373741881640485056",
    rare = "1373741979485081731",
    legendary = "1373742089480700084",
    bug = "1373742311162511370",
    mythical = "1373742422189674639",
    common_summer = "1386095307347197972",
    paradise = "1386095178732802129",
    rare_summer = "1386095389811282162"
}

function stocksAreDifferent(a, b)
    if #a ~= #b then return true end
    for i = 1, #a do
        if a[i].EggName ~= b[i].EggName or a[i].Price ~= b[i].Price then
            return true
        end
    end
    return false
end

function deepCopy(tbl)
    local copy = {}
    for i = 1, #tbl do
        local v = tbl[i]
        copy[i] = { EggName = v.EggName, Price = v.Price }
    end
    return copy
end

LeftGroupbox:AddToggle("EggToggle", {
    Text = "Egg WebHook",
    Default = false,
    Tooltip = "Enable/Disable Egg WebHook",
    Callback = function(Value)
        if Value then
            if not sendingLoopRunning then
                sendingLoopRunning = true
                sendingLoopThread = spawn(function()
                    while sendingLoopRunning do
                        petEggStock = DataService_upvr:GetData().PetEggStock.Stocks
                        currentSnapshot = {}

                        for _, stockEntry in pairs(petEggStock) do
                            eggName = stockEntry.EggName
                            eggData = PetEggData_upvr[eggName]
                            if eggData then
                                currentSnapshot[#currentSnapshot + 1] = {
                                    EggName = eggName,
                                    Price = eggData.Price
                                }
                            else
                                warn("No data found for egg: " .. eggName)
                            end
                        end

                        if stocksAreDifferent(currentSnapshot, lastStockSnapshot) then
                            lastStockSnapshot = deepCopy(currentSnapshot)

                            stockLines = {}
                            mentionedRoles = {}

                            for i = 1, #currentSnapshot do
                                entry = currentSnapshot[i]
                                stockLines[#stockLines + 1] = string.format("%s ü•ö: %d", entry.EggName, entry.Price)

                                eggNameLower = entry.EggName:lower()
                                if eggNameLower:find("legendary") then
                                    mentionedRoles[#mentionedRoles + 1] = roleIds.legendary
                                elseif eggNameLower:find("mythical") then
                                    mentionedRoles[#mentionedRoles + 1] = roleIds.mythical
                                elseif eggNameLower:find("bug") then
                                    mentionedRoles[#mentionedRoles + 1] = roleIds.bug
                                elseif eggNameLower:find("rare") then
                                    if eggNameLower:find("summer") then
                                        mentionedRoles[#mentionedRoles + 1] = roleIds.rare_summer
                                    else
                                        mentionedRoles[#mentionedRoles + 1] = roleIds.rare
                                    end
                                elseif eggNameLower:find("uncommon") then
                                    mentionedRoles[#mentionedRoles + 1] = roleIds.uncommon
                                elseif eggNameLower:find("common") then
                                    if eggNameLower:find("summer") then
                                        mentionedRoles[#mentionedRoles + 1] = roleIds.common_summer
                                    else
                                        mentionedRoles[#mentionedRoles + 1] = roleIds.common
                                    end
                                elseif eggNameLower:find("paradise") then
                                    mentionedRoles[#mentionedRoles + 1] = roleIds.paradise
                                end
                            end

                            roleMentionString = ""
                            for i = 1, #mentionedRoles do
                                roleMentionString = roleMentionString .. "<@&" .. mentionedRoles[i] .. "> "
                            end

                            payload = {
                                content = roleMentionString,
                                embeds = {{
                                    title = "Pet Egg Stock Prices",
                                    description = table.concat(stockLines, "\n"),
                                    color = 0x00FF00,
                                    timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ", os.time())
                                }}
                            }

                            jsonData = HttpService:JSONEncode(payload)

                            success, response = pcall(function()
                                return http_request({
                                    Url = eggWebhookUrl,
                                    Method = "POST",
                                    Headers = { ["Content-Type"] = "application/json" },
                                    Body = jsonData
                                })
                            end)

                            if success and response and (response.Success or response.StatusCode == 204 or response.StatusCode == 200) then
                                print("‚úÖ Webhook sent")
                            else
                                warn("‚ùå Webhook failed")
                                if response then
                                    warn("Response: " .. tostring(response.Body or response.StatusMessage or "No response body"))
                                end
                            end
                        end

                        wait(3)
                    end
                end)
            end
        else
            sendingLoopRunning = false
        end
    end
})





-------------------------
--====INPUTS UI====--  
-------------------------

LeftGroupbox:AddInput("WeatherWebhookInput", {
    Text = "Weather Webhook URL",
    Default = weatherWebhookUrl,
    Numeric = false,
    Finished = true,
    Placeholder = "Enter Weather Discord webhook URL...",
    Callback = function(Value)
        if Value ~= "" then
            weatherWebhookUrl = Value
            print("Weather webhook URL updated:", Value)
        end
    end
})

LeftGroupbox:AddInput("EggWebhookInput", {
    Text = "Egg Webhook URL",
    Default = eggWebhookUrl,
    Numeric = false,
    Finished = true,
    Placeholder = "Enter Egg Discord webhook URL...",
    Callback = function(Value)
        if Value ~= "" then
            eggWebhookUrl = Value
            print("Egg webhook URL updated:", Value)
        end
    end
})

LeftGroupbox:AddInput("WeatherRoleIdInput", {
    Text = "Weather Role ID",
    Default = weatherRoleId,
    Numeric = false,
    Finished = true,
    Placeholder = "Enter Discord Role ID for weather mentions...",
    Callback = function(Value)
        if Value ~= "" then
            weatherRoleId = Value
            print("Weather role ID updated (dynamic):", Value)
        end
    end
})

LeftGroupbox:AddInput("EggRoleIdInput", {
    Text = "Egg Role ID",
    Default = eggRoleId,
    Numeric = false,
    Finished = true,
    Placeholder = "Enter Discord Role ID for egg mentions...",
    Callback = function(Value)
        if Value ~= "" then
            eggRoleId = Value
            print("Egg role ID updated:", Value)
        end
    end
})










local RightGroupbox = WebHookTab:AddRightGroupbox("BloodMoon/Moon Tracker", "moon")

loadstring([[
local LeftGroupbox, RightGroupbox = ...

local HttpService = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Require DataService safely
local DataService
local success, result = pcall(function()
    local moduleInstance = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("DataService")
    local clonedModule = moduleInstance:Clone()
    clonedModule.Parent = ReplicatedStorage
    local dataService = require(clonedModule)
    clonedModule:Destroy()
    return dataService
end)

if success then
    DataService = result
else
    warn("‚ùå Failed to require DataService module:", result)
end

if not DataService then
    error("‚ùå DataService is nil.")
end

if type(DataService.GetData) ~= "function" then
    error("‚ùå DataService:GetData is not a valid function.")
end

local EventShopData = require(ReplicatedStorage:WaitForChild("Data"):WaitForChild("EventShopData"))
local NightEventShopData = require(ReplicatedStorage:WaitForChild("Data"):WaitForChild("NightEventShopData"))

-- Shared webhook URL and Role ID variables
local webhookUrl = "PLACEHERE"
local mentionRoleId = "PLACEHERE"

-- BloodMoon UI toggles and inputs
local MyToggle = RightGroupbox:AddToggle("MyToggle", {
    Text = "Enable BloodMoon .REMOVED.",
    Default = false,
    Tooltip = "Toggle webhook on BloodMoon event",
    Callback = function(value)
        print("[Toggle] BloodMoon webhook enabled:", value)
        if value and workspace:GetAttribute("BloodMoonEvent") then
            task.defer(function()
                task.wait(3)
                SendBloodMoonStockWebhook()
            end)
        end
    end
})

local WebhookInput = RightGroupbox:AddInput("WebhookInput", {
    Default = webhookUrl,
    Numeric = false,
    Text = "Webhook URL",
    Tooltip = "Set the Discord webhook URL",
    Placeholder = "Paste webhook URL here",
    Callback = function(value)
        webhookUrl = value
        print("[Input] Webhook URL updated:", webhookUrl)
    end
})

local RoleIdInput = RightGroupbox:AddInput("RoleIdInput", {
    Default = mentionRoleId,
    Numeric = false,
    Text = "Mention Role ID",
    Tooltip = "Set the Discord Role ID to mention",
    Placeholder = "Enter role ID",
    Callback = function(value)
        mentionRoleId = value
        print("[Input] Mention Role ID updated:", mentionRoleId)
    end
})

-- NightEvent UI toggles (added)
local NightToggle = RightGroupbox:AddToggle("NightToggle", {
    Text = "Enable NightEvent Stock Webhook",
    Default = false,
    Tooltip = "Toggle webhook on NightEvent",
    Callback = function(value)
        print("[Toggle] NightEvent webhook enabled:", value)
        if value and workspace:GetAttribute("NightEvent") then
            task.defer(function()
                task.wait(5)
                SendNightEventStockWebhook()
            end)
        end
    end
})

-- BloodMoon webhook function
function SendBloodMoonStockWebhook()
    if not MyToggle.Value then
        print("[SendBloodMoonStockWebhook] Skipped: Toggle is off")
        return
    end

    local stockData = DataService:GetData().EventShopStock.Stocks
    local fields = {}

    for itemId, itemInfo in pairs(EventShopData) do
        if itemInfo.DisplayInShop then
            local displayName = itemInfo.SeedName or itemId
            local stockEntry = stockData[itemId]
            local stockAmount = stockEntry and stockEntry.Stock or 0

            local valueText = string.format("üì¶ Stock: %d", stockAmount)
            local price = itemInfo.Price or 0
            valueText = string.format("üíµ Price: %s\n%s", tostring(price), valueText)

            table.insert(fields, {
                name = displayName,
                value = valueText,
                inline = true
            })
        end
    end

    local payload = {
        content = "<@&" .. mentionRoleId .. ">",
        embeds = {{
            title = "üåï Blood Moon Stock Report",
            description = "The Blood Moon has begun. Here's all stock data.",
            color = 16711680,
            fields = fields,
            timestamp = DateTime.now():ToIsoDate()
        }}
    }

    local request = http_request or http and http.request or request
    if not request then
        warn("‚ùå HTTP request function not found.")
        return
    end

    local success, err = pcall(function()
        request({
            Url = webhookUrl,
            Method = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body = HttpService:JSONEncode(payload)
        })
    end)

    if success then
        print("‚úÖ BloodMoon stock report sent successfully.")
    else
        warn("‚ùå Failed to send BloodMoon stock report:", err)
    end
end

-- NightEvent webhook function (new)
function SendNightEventStockWebhook()
    if not NightToggle.Value then
        print("[SendNightEventStockWebhook] Skipped: Toggle is off")
        return
    end

    local data = DataService:GetData()
    local stockData = data.NightEventShopStock and data.NightEventShopStock.Stocks or {}
    local fields = {}

    for itemId, itemInfo in pairs(NightEventShopData) do
        if itemInfo.DisplayInShop then
            local displayName = itemInfo.SeedName or itemId
            local stockEntry = stockData[itemId]
            local stockAmount = stockEntry and stockEntry.Stock or 0

            local valueText = string.format("üì¶ Stock: %d", stockAmount)
            local price = itemInfo.Price or 0
            valueText = string.format("üíµ Price: %s\n%s", tostring(price), valueText)

            table.insert(fields, {
                name = displayName,
                value = valueText,
                inline = true
            })
        end
    end

    local payload = {
        content = "<@&" .. mentionRoleId .. ">",
        embeds = {{
            title = "üåô Night Event Stock Report",
            description = "The Night Event has begun. Here's all stock data.",
            color = 255255255, -- white, or change color if you want
            fields = fields,
            timestamp = DateTime.now():ToIsoDate()
        }}
    }

    local request = http_request or http and http.request or request
    if not request then
        warn("‚ùå HTTP request function not found.")
        return
    end

    local success, err = pcall(function()
        request({
            Url = webhookUrl,
            Method = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body = HttpService:JSONEncode(payload)
        })
    end)

    if success then
        print("‚úÖ NightEvent stock report sent successfully.")
    else
        warn("‚ùå Failed to send NightEvent stock report:", err)
    end
end

-- BloodMoon event listener
workspace:GetAttributeChangedSignal("BloodMoonEvent"):Connect(function()
    if workspace:GetAttribute("BloodMoonEvent") then
        if MyToggle.Value then
            task.wait(3)
            SendBloodMoonStockWebhook()
        end
    end
end)

if workspace:GetAttribute("BloodMoonEvent") and MyToggle.Value then
    task.defer(function()
        task.wait(3)
        SendBloodMoonStockWebhook()
    end)
end

-- NightEvent event listener
workspace:GetAttributeChangedSignal("NightEvent"):Connect(function()
    if workspace:GetAttribute("NightEvent") then
        if NightToggle.Value then
            task.wait(5)
            SendNightEventStockWebhook()
        end
    end
end)

if workspace:GetAttribute("NightEvent") and NightToggle.Value then
    task.defer(function()
        task.wait(5)
        SendNightEventStockWebhook()
    end)
end
]])(LeftGroupbox, RightGroupbox)










getgenv().RightGroupbox = WebHookTab:AddRightGroupbox("Cosmetic Stock Traker", "paintbrush")

-- Webhook URL input
getgenv().WebhookUrlInput = getgenv().RightGroupbox:AddInput("WebhookUrlInput", {
    Text = "Webhook URL",
    Default = "",
    Numeric = false,
    Finished = true,
    Placeholder = "Enter webhook URL here...",
    Tooltip = "Cosmetic Stock Tracker",
    Callback = function(Value)
        print("Webhook URL updated:", Value)
    end
})

-- Role ID input
getgenv().RoleIdInput = getgenv().RightGroupbox:AddInput("RoleIdInput", {
    Text = "Role ID",
    Default = "1376172220807647302",  -- Default role ID set here
    Numeric = false,
    Finished = true,
    Placeholder = "Enter Discord Role ID here...",
    Tooltip = "TIME THIS WITH STOCK CHANGE FOR BEST RESULTS!!!!",
    Callback = function(Value)
        print("Role ID updated:", Value)
    end
})

local lastCosmeticSnapshot = ""
local runWebhookLoop = false

local function serializeCosmeticStock(itemStocks, crateStocks)
    local serialized = {}

    for name, stockData in pairs(itemStocks) do
        table.insert(serialized, name .. ":" .. tostring(stockData.Stock or 0))
    end
    for name, stockData in pairs(crateStocks) do
        table.insert(serialized, name .. ":" .. tostring(stockData.Stock or 0))
    end

    table.sort(serialized)
    return table.concat(serialized, ",")
end

local function SendCosmeticShopStock()
    local WEBHOOK_URL = getgenv().WebhookUrlInput.Value
    if WEBHOOK_URL == nil or WEBHOOK_URL == "" then
        WEBHOOK_URL = "https://discord.com/api/webhooks/1374749748774305832/szhmogvvwLb3EgkQMYsg1N9uVpz2FUPLC8MGigigL_59oilweAhx9HSeJMhqLQ6wj8BZ"
    end

    local roleId = getgenv().RoleIdInput.Value
    local mentionText = (roleId ~= nil and roleId ~= "") and string.format("<@&%s>", roleId) or ""

    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Players = game:GetService("Players")
    local player = Players.LocalPlayer

    local DataService = require(ReplicatedStorage:WaitForChild("Modules"):WaitForChild("DataService"))
    local CosmeticItemData = require(ReplicatedStorage:WaitForChild("Data"):WaitForChild("CosmeticItemShopData"))
    local CosmeticCrateData = require(ReplicatedStorage:WaitForChild("Data"):WaitForChild("CosmeticCrateShopData"))
    local NumberUtil = require(ReplicatedStorage:WaitForChild("Modules"):WaitForChild("NumberUtil"))

    local data = DataService:GetData()
    local itemStocks = data.CosmeticStock.ItemStocks or {}
    local crateStocks = data.CosmeticStock.CrateStocks or {}

    -- Check for changes
    local currentSnapshot = serializeCosmeticStock(itemStocks, crateStocks)
    if currentSnapshot == lastCosmeticSnapshot then return end
    lastCosmeticSnapshot = currentSnapshot

    local function formatStockTable(stockTable, dataTable, label)
        local output = "**" .. label .. "**\n"
        for name, stockData in pairs(stockTable) do
            local info = dataTable[name]
            local price = info and info.Price or "?"
            local stock = stockData.Stock or 0
            local formattedPrice = info and NumberUtil.FormatCompactPrice(price) or "Unknown"
            output = output .. string.format("`%s` - Stock: **%s**, Price: **%s**\n", name, stock, formattedPrice)
        end
        return output
    end

    local itemsText = formatStockTable(itemStocks, CosmeticItemData, "Items")
    local cratesText = formatStockTable(crateStocks, CosmeticCrateData, "Crates")

    local embed = {
        ["title"] = "üõçÔ∏è Cosmetic Shop Stock",
        ["description"] = itemsText .. "\n\n" .. cratesText,
        ["color"] = 0x00ffcc,
        ["footer"] = {
            ["text"] = "Generated by Polluted"
        },
        ["timestamp"] = os.date("!%Y-%m-%dT%H:%M:%SZ")
    }

    local payload = {
        ["content"] = mentionText,
        ["embeds"] = { embed }
    }

    local success, err = pcall(function()
        http_request({
            Url = WEBHOOK_URL,
            Method = "POST",
            Headers = {
                ["Content-Type"] = "application/json"
            },
            Body = game:GetService("HttpService"):JSONEncode(payload)
        })
    end)

    if success then
        print("[Webhook] Sent cosmetic shop stock to Discord.")
    else
        warn("[Webhook] Failed to send webhook:", err)
    end
end

getgenv().MyToggle = getgenv().RightGroupbox:AddToggle("MyToggle", {
    Text = "Send Cosmetic Shop Stock to Webhook",
    Default = false,
    Tooltip = "Sends update every time stock changes!",
    Callback = function(Value)
        if Value then
            runWebhookLoop = true
            spawn(function()
                while runWebhookLoop do
                    SendCosmeticShopStock()
                    wait(3)
                end
            end)
        else
            runWebhookLoop = false
        end
    end
})



local RightGroupbox = WebHookTab:AddRightGroupbox("Honey Stock Tracker", "bug")

-- Executor Script to monitor stock changes and send a neat, spaced-out webhook embed only if stock changes

-- Services we need to interact with
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Player = game.Players.LocalPlayer
local DataService = require(ReplicatedStorage.Modules.DataService)
local CommaModule = require(ReplicatedStorage.Comma_Module)  -- For comma formatting of prices

-- Get Honey Event Shop data
local honeyShopData = require(ReplicatedStorage.Data.HoneyEventShopData)

-- Define Cosmetics items
local cosmetics = {"Bee Chair", "Honey Torch", "Honey Walkway", "Honey Comb"}

-- Webhook URL (this will be updated through input)
local webhookUrl = ""
-- Role ID (this will be updated through input)
local roleId = ""

-- Table to store previous stock values
local previousStocks = {}  -- Table to store previous stock values

-- Input for webhook URL
local WebhookInput = RightGroupbox:AddInput("WebhookInput", {
    Text = "Webhook URL",
    Default = "",
    Numeric = false,
    Finished = true,
    Placeholder = "Enter Discord webhook URL here...",
    Callback = function(Value)
        webhookUrl = Value
        print("Webhook URL updated:", webhookUrl)
    end
})

-- Input for Role ID to ping
local RoleInput = RightGroupbox:AddInput("RoleInput", {
    Text = "Role ID to Ping",
    Default = "",
    Numeric = true,
    Finished = true,
    Placeholder = "Enter role ID here to ping",
    Callback = function(Value)
        roleId = Value
        print("Role ID updated:", roleId)
    end
})

-- Function to send a neat, spaced-out webhook embed with categorized item details
local function sendWebhookEmbed(rolePing, cosmeticsData, equipmentData, totalPrice)
    local embedData = {
        embeds = {
            {
                title = "üêùüêù",  -- Replaced title with emoji
                description = "Here are the latest updates for all items in the Honey Event Shop:",
                fields = {},
                color = 16776960, -- Gold color
                footer = {
                    text = "Total Price: " .. CommaModule.Comma(totalPrice) .. " Honey"
                },
                timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ"),  -- Timestamp of when the embed was created
            }
        }
    }

    -- Add Equipment section (left side)
    if #equipmentData > 0 then
        table.insert(embedData.embeds[1].fields, {
            name = "_**Equipment**_",  -- Underlined section title
            value = table.concat(equipmentData, "\n"),
            inline = true
        })
    end

    -- Add Cosmetics section (right side)
    if #cosmeticsData > 0 then
        table.insert(embedData.embeds[1].fields, {
            name = "_**Cosmetics**_",  -- Underlined section title
            value = table.concat(cosmeticsData, "\n"),
            inline = true
        })
    end

    local jsonData = game:GetService("HttpService"):JSONEncode(embedData)

    -- Make a POST request to the webhook URL
    local requestFunction = http_request or (syn and syn.request)

    -- Send the role ping along with the embed
    local response = requestFunction({
        Url = webhookUrl,
        Method = "POST",
        Headers = {
            ["Content-Type"] = "application/json"
        },
        Body = game:GetService("HttpService"):JSONEncode({
            content = rolePing,  -- Role ping here
            embeds = embedData.embeds
        })
    })
    
    return response
end

-- Function to monitor stock changes and send a clean, neat update if stock has changed
local function monitorStockChanges()
    local cosmeticsData = {}  -- Table to store Cosmetics item data
    local equipmentData = {}   -- Table to store Equipment item data
    local totalPrice = 0  -- Variable to accumulate total price of all items in stock

    local stockChanged = false  -- Flag to track if stock has changed

    -- Iterate through the items in Honey Event Shop data
    for itemID, itemData in pairs(honeyShopData) do
        if itemData.DisplayInShop then
            -- Access stock data from the player's data (EventShopStock)
            local stockData = DataService:GetData().EventShopStock.Stocks[itemID]
            local stock = stockData and stockData.Stock or 0  -- Default to 0 stock if none found

            -- Skip items with 0 stock
            if stock == 0 then
                continue
            end

            -- Get the price data
            local priceText
            local itemTotalPrice = 0
            if itemData.Price then
                if itemData.SpecialCurrencyType then
                    -- Special currency type (same as Honey here)
                    priceText = CommaModule.Comma(itemData.Price) .. " Honey"  -- Price in Honey
                else
                    -- Regular price with Honey as currency
                    priceText = CommaModule.Comma(itemData.Price) .. " Honey"
                end

                -- Calculate total price for this item (stock * price)
                itemTotalPrice = itemData.Price * stock
            else
                -- If no price exists
                priceText = "No Price"
            end

            -- Add this item‚Äôs total price to the overall total
            totalPrice = totalPrice + itemTotalPrice

            -- Prepare the item data string (underline the item name)
            local itemDataString = string.format("__%s__\nStock = %d | %s\n------------------------", itemData.SeedName, stock, priceText)

            -- Check if the item is a cosmetic or equipment
            if table.find(cosmetics, itemData.SeedName) then
                -- Add cosmetic item data
                table.insert(cosmeticsData, itemDataString)
            else
                -- All other items are considered equipment
                table.insert(equipmentData, itemDataString)
            end

            -- Check if the stock has changed since the last check
            if previousStocks[itemID] ~= stock then
                stockChanged = true  -- Mark that stock has changed
            end

            -- Update previous stock value
            previousStocks[itemID] = stock
        end
    end

    -- If stock has changed for any item, send the combined data in one embed
    if stockChanged then
        -- Ping the role outside the embed
        local rolePingContent = (roleId ~= "" and ("<@&" .. roleId .. ">") or "")  -- Role ping (replace with your role ID if set)

        -- Send the role ping followed by the embed with item data
        sendWebhookEmbed(rolePingContent, cosmeticsData, equipmentData, totalPrice)
    end
end

-- Toggle to start/stop stock monitoring
local sendToggle = RightGroupbox:AddToggle("SendToggle", {
    Text = "Send Honey Shop Stock to Webhook (On Stock Change)",
    Default = false,
    Tooltip = "Toggle to start/stop sending Honey Shop stock embed when stock changes",
    Callback = function(Value)
        if Value then
            -- Check if webhook URL is valid before starting the loop
            if webhookUrl == nil or webhookUrl == "" then
                warn("Please enter a valid webhook URL before enabling.")
                -- Reset the toggle state
                sendToggle:SetValue(false)
                return
            end

            -- Start the stock monitoring loop in a separate thread
            spawn(function()
                while true do
                    monitorStockChanges()
                    wait(5)  -- Wait for 5 seconds before checking again
                end
            end)
        else
            -- Stop the monitoring loop
            print("Monitoring stopped.")
        end
    end
})








-- UI: RightGroupbox for Fun Cmds
local RightGroupbox = WebHookTab:AddRightGroupbox("Chat Cmds All Players", "message-circle-more")

-- Toggle: Enable Webhook Chat Cmds
local WebhookToggle = RightGroupbox:AddToggle("WebhookCmds", {
    Text = "Enable Webhook Chat Cmds",
    Default = false,
    Tooltip = "Enables !value, !held, !gme, and !display webhook triggers.",
    Callback = function(Value)
        if _G.ToggleWebHookChat then
            _G.ToggleWebHookChat(Value)
        end
    end
})

-- Input: Webhook URL override
local WebhookURLInput = RightGroupbox:AddInput("WebhookURLInput", {
    Text = "Webhook URL",
    Default = "https://discord.com/api/webhooks/1376950748033847397/AWGautkW-nFz6T0MBwP3SZ4msk16pX3ahrGogXs_uHIwxuMVpKTPVSEAAz1DA8EZQVDw",
    Numeric = false,
    Finished = true,
    Placeholder = "Enter Webhook URL...",
    Callback = function(Value)
        if typeof(Value) == "string" and string.find(Value, "https://discord.com/api/webhooks/") then
            _G.WebhookURL = Value
            print("Webhook URL updated:", Value)
        else
            print("Invalid webhook URL format.")
        end
    end
})

-- Main Logic
loadstring([[

local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Item_Module = require(ReplicatedStorage.Item_Module)
local MutationHandler = require(ReplicatedStorage.Modules.MutationHandler)

-- Default Webhook URL (can be overridden by _G.WebhookURL)
local defaultWebhookURL = "https://discord.com/api/webhooks/1376950748033847397/AWGautkW-nFz6T0MBwP3SZ4msk16pX3ahrGogXs_uHIwxuMVpKTPVSEAAz1DA8EZQVDw"

local function getWebhookURL()
	return _G.WebhookURL or defaultWebhookURL
end

local function formatNumber(n)
	if n >= 1e12 then
		return string.format("%.2fT", n / 1e12)
	elseif n >= 1e9 then
		return string.format("%.2fB", n / 1e9)
	elseif n >= 1e6 then
		return string.format("%.2fM", n / 1e6)
	elseif n >= 1e3 then
		return string.format("%.2fK", n / 1e3)
	else
		return tostring(n)
	end
end

local function CalculatePlantValue(p4)
	local v5 = p4:FindFirstChild("Item_String")
	if not v5 then return 0 end
	local v6 = p4:FindFirstChild("Variant")
	if not v6 then return 0 end
	local v7 = p4:FindFirstChild("Weight")
	if not v7 then return 0 end

	local v8 = Item_Module.Return_Data(v5.Value)
	if not v8 or #v8 < 3 then
		warn("CalculatePlantValue | ItemData is invalid for " .. p4.Name)
		return 0
	end

	local v9 = v8[3]
	local v10 = v8[2]
	local v11 = Item_Module.Return_Multiplier(v6.Value)
	local v12 = v9 * MutationHandler:CalcValueMulti(p4) * v11
	local v13 = v7.Value / v10
	local v14 = math.clamp(v13, 0.95, 100000000)
	local v15 = v12 * (v14 * v14)

	return math.round(v15)
end

local function CalculateInventoryValue(player)
	local totalValue = 0
	local backpack = player:FindFirstChild("Backpack")
	if not backpack then return 0 end

	local excludeKeywords = { "Seed", "Sprinkler", "Watering", "Egg", "Rod", "Staff" }

	for _, item in pairs(backpack:GetChildren()) do
		local itemName = item.Name:lower()
		local shouldExclude = false
		for _, keyword in ipairs(excludeKeywords) do
			if itemName:find(keyword:lower()) then
				shouldExclude = true
				break
			end
		end

		if not shouldExclude then
			local success, val = pcall(CalculatePlantValue, item)
			if success and type(val) == "number" then
				totalValue = totalValue + val
			end
		end
	end

	return totalValue
end

local function sendWebhook(player, message, value, isHeld, heldItemName, itemName)
	local formatted = formatNumber(value)
	local title = isHeld and "Held Item Value" or (itemName and "Highest Value Item" or "Chat Command Detected")

	local description
	if isHeld then
		description = "**Player:** " .. player.Name .. "\n**Item:** " .. (heldItemName or "Unknown") .. "\n**Value:** " .. formatted
	elseif itemName then
		description = "**Player:** " .. player.Name .. "\n**Item:** " .. itemName .. "\n**Value:** " .. formatted
	else
		description = "**Player:** " .. player.Name .. "\n**Message:** " .. message .. "\n**Total Backpack Value:** " .. formatted
	end

	local data = {
		embeds = {{
			title = title,
			description = description,
			color = isHeld and 0x3498db or 0x00ff00,
			timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ"),
		}}
	}

	local jsonData = HttpService:JSONEncode(data)

	local requestFunction = http_request or (syn and syn.request)
	if requestFunction then
		pcall(function()
			requestFunction({
				Url = getWebhookURL(),
				Method = "POST",
				Headers = {
					["Content-Type"] = "application/json"
				},
				Body = jsonData
			})
		end)
	end
end

local connections = {}

local function onPlayerChatted(player)
	local connection = player.Chatted:Connect(function(message)
		local lowerMessage = message:lower()

		if lowerMessage == "!value" or lowerMessage == "!wealth" then
			local totalValue = CalculateInventoryValue(player)
			sendWebhook(player, message, totalValue, false)

		elseif lowerMessage == "!value held" then
			local character = player.Character
			if character then
				local heldItem = character:FindFirstChildOfClass("Tool")
				if heldItem and heldItem:FindFirstChild("Item_String") and heldItem:FindFirstChild("Variant") and heldItem:FindFirstChild("Weight") then
					local success, val = pcall(CalculatePlantValue, heldItem)
					if success and type(val) == "number" then
						sendWebhook(player, message, val, true, heldItem.Name)
					end
				end
			end

		elseif lowerMessage == "!gme" then
			local backpack = player:FindFirstChild("Backpack")
			if backpack then
				local excludeKeywords = { "Seed", "Sprinkler", "Watering", "Egg", "Rod", "Staff" }
				local highestValue, highestItem = 0, nil
				for _, item in pairs(backpack:GetChildren()) do
					local lowerName = item.Name:lower()
					local excluded = false
					for _, keyword in ipairs(excludeKeywords) do
						if lowerName:find(keyword:lower()) then
							excluded = true
							break
						end
					end
					if not excluded then
						local success, val = pcall(CalculatePlantValue, item)
						if success and val > highestValue then
							highestValue = val
							highestItem = item
						end
					end
				end
				if highestItem then
					sendWebhook(player, message, highestValue, false, nil, highestItem.Name)
				end
			end

		elseif lowerMessage == "!display" then
			local character = player.Character
			if character then
				local heldItem = character:FindFirstChildOfClass("Tool")
				if heldItem then
					local data = {
						embeds = {{
							title = "Display Command Used",
							description = "**Player:** " .. player.Name .. "\n**Held Item:** " .. heldItem.Name,
							color = 0xffa500,
							timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ"),
						}}
					}
					local jsonData = HttpService:JSONEncode(data)
					local requestFunction = http_request or (syn and syn.request)
					if requestFunction then
						pcall(function()
							requestFunction({
								Url = getWebhookURL(),
								Method = "POST",
								Headers = {
									["Content-Type"] = "application/json"
								},
								Body = jsonData
							})
						end)
					end
				end
			end
		end
	end)

	connections[player] = connection
end

local function EnableWebhookCommands(enabled)
	if enabled then
		for _, player in pairs(Players:GetPlayers()) do
			if not connections[player] then
				onPlayerChatted(player)
			end
		end
		Players.PlayerAdded:Connect(function(player)
			task.wait(1)
			onPlayerChatted(player)
		end)
	else
		for player, connection in pairs(connections) do
			if connection and connection.Disconnect then
				connection:Disconnect()
			end
		end
		connections = {}
	end
end

-- Expose toggle handler globally
_G.ToggleWebHookChat = EnableWebhookCommands

]])()














local LeftGroupbox = WebHookTab:AddLeftGroupbox("Seed&Gear Stock", "store")

loadstring([[

local LeftGroupbox, RightGroupbox = ...

local WebhookSettings = {
    WebhookURL = "PLACE HERE", -- for seed stock
    GearWebhookURL = "PLACE HERE", -- for gear stock
    SeedRoleID = "PLACE HERE",
    GearRoleID = "PLACE HERE"
}

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")

local DataService
local success, result = pcall(function()
    local moduleInstance = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("DataService")
    local clonedModule = moduleInstance:Clone()
    clonedModule.Parent = ReplicatedStorage
    local dataService = require(clonedModule)
    clonedModule:Destroy()
    return dataService
end)

if success then
    DataService = result
else
    warn("‚ùå Failed to require DataService module:", result)
end

if not DataService then
    error("‚ùå DataService is nil.")
end

if type(DataService.GetData) ~= "function" then
    error("‚ùå DataService:GetData is not a valid function.")
end

local GearData = require(ReplicatedStorage:WaitForChild("Data"):WaitForChild("GearData"))
local SeedData = require(ReplicatedStorage:WaitForChild("Data"):WaitForChild("SeedData"))
local Comma_Module = require(ReplicatedStorage:WaitForChild("Comma_Module"))

-- Updated emojiMap with new seeds
local emojiMap = {
    Carrot = "ü•ï", Tomato = "üçÖ", Corn = "üåΩ", Potato = "ü•î", Onion = "üßÖ",
    Lettuce = "ü•¨", Pumpkin = "üéÉ", Cabbage = "ü•¨", Beetroot = "ü´í", Radish = "üå∂Ô∏è",
    Grape = "üçá", Strawberry = "üçì", ["Dragon Fruit"] = "üêâüçé", Blueberry = "ü´ê",
    Mushroom = "üçÑ", Pepper = "üå∂Ô∏è", Cacao = "üç´", Beanstalk = "üå±", Mango = "ü•≠",
    Daffodil = "üåº", Watermelon = "üçâ", ["Orange Tulip"] = "üå∑üü†", Apple = "üçé",
    Bamboo = "üéç", Cactus = "üåµ", Coconut = "ü••", 
    ["Ember Lily"] = "üå∏üî•", Loquat = "üçë", Pineapple = "üçç", BellPepper = "ü´ë", 
    GreenApple = "üçè", Feijoa = "üçÉ", Avocado = "ü•ë", PricklyPear = "üçê", 
    Cauliflower = "ü•¶", Kiwi = "ü•ù", ["Sugar Apple"] = "üçèüç¨"
}

-- Updated seedRoleMap with new seeds
local seedRoleMap = {
    ["Orange Tulip"] = "1373738830053642322",
    Corn = "1373736607605325996",
    Apple = "1373736214817148928",
    ["Dragon Fruit"] = "1373737615899103243",
    Daffodil = "1373738941143847022",
    Tomato = "1373736815554723890",
    Pumpkin = "1373737010996445294",
    Bamboo = "1373737183206183104",
    Coconut = "1373737350001332261",
    Cacao = "1373738426112675860",
    Cactus = "1373737462735704125",
    Watermelon = "1373736326959988747",
    Blueberry = "1373736094864117841",
    Beanstalk = "1373738505519501525",
    Strawberry = "1373735969240645845",
    Mushroom = "1373738163377410199",
    Mango = "1373735842220347544",
    Grape = "1373735743217860618",
    Pepper = "1373736454844321864",
    ["Ember Lily"] = "1381297299891945525",
    Loquat = "1385960587330191421", -- Replace with actual role ID
    Pineapple = "1385960736844681346", -- Replace with actual role ID
    BellPepper = "1385960946685579347", -- Replace with actual role ID
    GreenApple = "1385961097659682896", -- Replace with actual role ID
    Feijoa = "1385961185320632320", -- Replace with actual role ID
    Avocado = "1385961374756245594", -- Replace with actual role ID
    PricklyPear = "1385961575369670768", -- Replace with actual role ID
    Cauliflower = "1385961821357477939", -- Replace with actual role ID
    Kiwi = "1385961950286053496", -- Replace with actual role ID
    ["Sugar Apple"] = "1382009762668871680" -- Replace with actual role ID
}

-- Updated gearRoleMap with Candy Apple
local gearRoleMap = {
    ["Watering Can"] = "1373744082626810006",
    ["Favorite Tool"] = "1373744268967018496",
    ["Basic Sprinkler"] = "1373743418131484692",
    ["Advanced Sprinkler"] = "1373743332437528739",
    ["Godly Sprinkler"] = "1373743215420637264",
    ["Master Sprinkler"] = "1373743078556438789",
    ["Recall Wrench"] = "1373743733513916537",
    ["Lightning Rod"] = "1373743624373928047",
}

local function getSeedStockDescription()
    local success, data = pcall(function()
        return DataService:GetData()
    end)

    if not success or not data or not data.SeedStock or not data.SeedStock.Stocks then
        return "Failed to retrieve seed stock data."
    end

    local messageLines = {}
    for seedName, stockInfo in pairs(data.SeedStock.Stocks) do
        if seedName ~= "Banana" then
            local stockAmount = stockInfo.Stock or 0
            local price = SeedData[seedName] and SeedData[seedName].Price or 0
            local priceStr = Comma_Module.Comma(price)
            local emoji = emojiMap[seedName] or ""
            table.insert(messageLines, string.format("%s **%s** - %d Stock (%s¬¢)", emoji, seedName, stockAmount, priceStr))
        end
    end

    return #messageLines > 0 and table.concat(messageLines, "\n") or "No seed stock available."
end

local function getCompactGearStock()
    local data = DataService:GetData()
    if not data or not data.GearStock or not data.GearStock.Stocks then
        return "No gear stock data available."
    end

    local stockStrs = {}
    for gearName, stockInfo in pairs(data.GearStock.Stocks) do
        if stockInfo and stockInfo.Stock then
            local price = GearData[gearName] and GearData[gearName].Price or 0
            local priceStr = Comma_Module.Comma(price)
            table.insert(stockStrs, string.format("**%s** - %d Stock (%s¬¢)", gearName, stockInfo.Stock, priceStr))
        end
    end

    return #stockStrs > 0 and table.concat(stockStrs, "\n") or "No gear items in stock."
end

local function containsTargetSeeds()
    local success, data = pcall(function()
        return DataService:GetData()
    end)
    if not success or not data or not data.SeedStock or not data.SeedStock.Stocks then
        return false
    end

    local mentions = {}
    for seedName, stockInfo in pairs(data.SeedStock.Stocks) do
        if seedRoleMap[seedName] and stockInfo.Stock and stockInfo.Stock > 0 then
            -- Add role mention for this seed item
            table.insert(mentions, string.format("<@&%s>", seedRoleMap[seedName]))
        end
    end

    -- Return mentions if any seed is in stock
    return #mentions > 0 and table.concat(mentions, " ") or nil
end

local function containsTargetGear()
    local success, data = pcall(function()
        return DataService:GetData()
    end)
    if not success or not data or not data.GearStock or not data.GearStock.Stocks then
        return false
    end

    local mentions = {}
    for gearName, stockInfo in pairs(data.GearStock.Stocks) do
        if gearRoleMap[gearName] and stockInfo.Stock and stockInfo.Stock > 0 then
            -- Add role mention for this gear item
            table.insert(mentions, string.format("<@&%s>", gearRoleMap[gearName]))
        end
    end

    -- Return mentions if any gear is in stock
    return #mentions > 0 and table.concat(mentions, " ") or nil
end

local function sendWebhook(url, payload)
    local jsonData = HttpService:JSONEncode(payload)
    local request = http_request or http and http.request or request
    if not request then
        warn("‚ùå HTTP request function not found.")
        return
    end

    local response = request({
        Url = url,
        Method = "POST",
        Headers = { ["Content-Type"] = "application/json" },
        Body = jsonData
    })

    if response and response.Success then
        print("‚úÖ Webhook sent successfully at " .. os.date("%X"))
    else
        warn("‚ùå Failed to send webhook:", response and (response.StatusMessage or response.StatusCode) or "Unknown error")
    end
end

local function sendWebhookWithTwoEmbeds()
    local seedDescription = getSeedStockDescription()
    local gearDescription = getCompactGearStock()

    -- Get seed and gear mentions
    local seedMentions = containsTargetSeeds()
    local gearMentions = containsTargetGear()

    local timeNow = os.time()

    -- Payload for seed stock
    local seedPayload = {
        content = (seedMentions or ""),
        embeds = {
            {
                title = "üå± Current Seed Stock",
                description = seedDescription,
                color = 65280,
                timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ"),
            }
        }
    }

    -- Payload for gear stock
    local gearPayload = {
        content = (gearMentions or ""),
        embeds = {
            {
                title = "üõí Gear Stock",
                description = gearDescription,
                color = 3066993,
                timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ"),
            }
        }
    }

    -- Send seed stock to the original WebhookURL
    sendWebhook(WebhookSettings.WebhookURL, seedPayload)

    -- Send gear stock to the separate GearWebhookURL if it's set
    if WebhookSettings.GearWebhookURL and WebhookSettings.GearWebhookURL ~= "" then
        sendWebhook(WebhookSettings.GearWebhookURL, gearPayload)
    end
end

-- Debug loop
local isDebugLooping = false
local debugLoopThread

LeftGroupbox:AddInput("WebhookInput", {
    Default = WebhookSettings.WebhookURL,
    Numeric = false,
    Text = "Webhook URL",
    Tooltip = "Set the Discord webhook URL.",
    Placeholder = "Paste webhook...",
    Callback = function(value)
        WebhookSettings.WebhookURL = value
        print("[Input] Webhook URL updated:", value)
    end
})

LeftGroupbox:AddInput("GearWebhookInput", {
    Default = WebhookSettings.GearWebhookURL,
    Numeric = false,
    Text = "Gear Webhook URL",
    Tooltip = "Set the Discord webhook URL for gear stock.",
    Placeholder = "Paste gear webhook...",
    Callback = function(value)
        WebhookSettings.GearWebhookURL = value
        print("[Input] Gear Webhook URL updated:", value)
    end
})

LeftGroupbox:AddInput("SeedRoleInput", {
    Default = WebhookSettings.SeedRoleID,
    Numeric = false,
    Text = "Seed Role ID",
    Tooltip = "Set the role ID for seed pings.",
    Placeholder = "Enter seed role ID...",
    Callback = function(value)
        WebhookSettings.SeedRoleID = value
        print("[Input] Seed Role ID updated:", value)
    end
})

LeftGroupbox:AddInput("GearRoleInput", {
    Default = WebhookSettings.GearRoleID,
    Numeric = false,
    Text = "Gear Role ID",
    Tooltip = "Set the role ID for gear pings.",
    Placeholder = "Enter gear role ID...",
    Callback = function(value)
        WebhookSettings.GearRoleID = value
        print("[Input] Gear Role ID updated:", value)
    end
})

LeftGroupbox:AddToggle("Enable Seed/Gear Stock", {
    Text = "Seed/Gear",
    Default = false,
    Tooltip = "Enable/Disable Seed/Gear Stock.",
    Callback = function(enabled)
        if enabled and not isDebugLooping then
            isDebugLooping = true
            print("[Stock Monitor] Enabled: Monitoring stock changes.")

            local lastSeedStock, lastGearStock = "", ""

            debugLoopThread = task.spawn(function()
                while isDebugLooping do
                    local currentSeed = getSeedStockDescription()
                    local currentGear = getCompactGearStock()

                    if currentSeed ~= lastSeedStock or currentGear ~= lastGearStock then
                        print("[Stock Monitor] Change detected. Sending webhook.")
                        sendWebhookWithTwoEmbeds()
                        lastSeedStock = currentSeed
                        lastGearStock = currentGear
                    end

                    task.wait(10) -- Check every 10 seconds
                end
            end)
        elseif not enabled and isDebugLooping then
            isDebugLooping = false
            print("[Stock Monitor] Disabled: Stopped monitoring.")
        end
    end
})











]])(LeftGroupbox, RightGroupbox)

























































--Robux Items





--------------------------------------------------------













-- TRADING























-- === UI Settings Tab ===
local Tabs = {
    ["UI Settings"] = Window:AddTab("UI Settings", "settings"),
}

-- Create groupbox for actions
local Groupbox = Tabs["UI Settings"]:AddLeftGroupbox("Ui Settings", "wrench")

-- UI visibility toggle
local MyToggle = Groupbox:AddToggle("ToggleUIVisibility", {
    Text = "UI Visibility",
    Default = true,
    Callback = function(Value)
        Library:Toggle(Value)
    end
})

-- Keybind for UI toggle
local Keybind = MyToggle:AddKeyPicker("MyKeybind", {
    Default = "RightAlt",
    Text = "Toggle UI Keybind",
    Mode = "Toggle",
    SyncToggleState = true,
    Callback = function(Value)
        print("Keybind toggled UI, now:", Value)
    end
})

-- Unload button
local Button = Groupbox:AddButton({
    Text = "Unload UI",
    Func = function()
        Library:Unload()
    end,
    DoubleClick = true
})

-- Notify user on script load
Library:Notify({
    Title = "Script Loaded",
    Description = "Press Right Alt to show/hide UI",
    Time = 5,
    SoundId = 11111
})

-- === UI Scale Dropdown ===
Groupbox:AddDropdown("UIScaleDropdown", {
    Values = {"75%", "90%", "105%", "120%", "135%", "150%"},
    Default = 2, -- Default is 90%
    Multi = false,
    Text = "UI Scale",
    Tooltip = "Select the UI scale percentage",
    Callback = function(Value)
        local numericValue = tonumber(Value:match("%d+"))
        if numericValue then
            Library:SetDPIScale(numericValue)
        end
    end
})

-- === Theme and Save Manager Setup ===
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
ThemeManager:SetFolder("ExampleFolder")
SaveManager:SetFolder("ExampleFolder/saves")
SaveManager:BuildConfigSection(Tabs["UI Settings"])
SaveManager:LoadAutoloadConfig()
ThemeManager:ApplyToTab(Tabs["UI Settings"])










